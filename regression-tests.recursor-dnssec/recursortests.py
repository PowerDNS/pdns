#!/usr/bin/env python2

import errno
import shutil
import os
import socket
import struct
import subprocess
import sys
import time
import unittest
import dns
import dns.message

class RecursorTest(unittest.TestCase):
    """
    Set up a recursor instance.
    """
    _recursorStartupDelay = 2.0
    _recursorPort = 5300
    _recursor = None
    _confdir = 'recursor'
    _config_template_default = """
daemon=no
trace=yes
dont-query=
local-address=127.0.0.1
packetcache-ttl=0
max-cache-ttl=15
threads=1
loglevel=9
disable-syslog=yes
"""
    _config_template = """
"""
    _config_params = []
    _lua_config_file = None
    _roothints = None
    _root_DS = None

    _PREFIX = os.environ['PREFIX']

    # The default SOA for zones in the authoritative servers
    _SOA = "ns.example.net. hostmaster.example.net. 1 3600 1800 1209600 300"

    # The definitions of the authoritative servers, the key is the suffix of the
    # IP address. The values are a dict of key zonename and the value is the
    # zonefile content. several strings are replaced:
    #   - {soa} => value of _SOA
    #   - {prefix} value of _PREFIX
    _auths_zones = {
        '8': {
            'ROOT': """
.                        3600 IN SOA {soa}
.                        3600 IN NS  ns.root.
ns.root.                 3600 IN A   {prefix}.8
net.                     3600 IN NS  ns.example.net.
net.                     3600 IN NS  ns2.example.net.
ns.example.net.          3600 IN A   {prefix}.10
ns2.example.net.         3600 IN A   {prefix}.11"""
            },
        '10': {
            'example.net': """
example.net.             3600 IN SOA {soa}
example.net.             3600 IN NS  ns.example.net.
example.net.             3600 IN NS  ns2.example.net.
ns.example.net.          3600 IN A   {prefix}.10
ns2.example.net.         3600 IN A   {prefix}.11
            """
            }
        }

    _launch_auths = True
    _auths = {}

    @classmethod
    def createConfigDir(cls, confdir):
        try:
            shutil.rmtree(confdir)
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise
        os.mkdir(confdir, 0755)

    @classmethod
    def generateAuthConfig(cls, confdir, suffix, zones):
        zonedir = os.path.join(confdir, 'zones-%s' % suffix)
        os.mkdir(zonedir)

        with open(os.path.join(confdir, 'named-%s.conf' % suffix), 'w') as namedconf:
            namedconf.write("""
options {
    directory "./%s";
};""" % zonedir)
            for zonename, zonecontent in zones.items():
                zone = '.' if zonename == 'ROOT' else zonename
                with open(os.path.join(zonedir, '%s.zone' % zone), 'w') as zonefile:
                    zonefile.write(zonecontent.format(prefix=cls._PREFIX, soa=cls._SOA))
                namedconf.write("""
zone "%s"{
    type master;
    file "./%s.zone";
};""" % (zone, zonename))

        with open(os.path.join(confdir, 'pdns-%s.conf' % suffix), 'w') as pdnsconf:
            pdnsconf.write("""
module-dir=../regression-tests/modules
launch=bind
daemon=no
local-address={ipaddress}
local-ipv6=
bind-config={confdir}/named-{suffix}.conf
no-shuffle
socket-dir={confdir}
cache-ttl=0
negquery-cache-ttl=0
query-cache-ttl=0
distributor-threads=1""".format(ipaddress = cls._PREFIX + '.' + suffix, suffix = suffix, confdir = confdir))


    @classmethod
    def startAuth(cls, confdir, suffix):
        print("Launching pdns_server..")
        authcmd = [ 'authbind',
                    os.environ['PDNS'],
                    '--config-dir=%s' % confdir,
                    '--config-name=%s' % suffix]
        print(' '.join(authcmd))

        logFile = os.path.join(confdir, 'auth-%s.log' % suffix)
        with open(logFile, 'w') as fdLog:
            cls._auths[suffix] = subprocess.Popen(authcmd, close_fds=True,
                                                  stdout=fdLog, stderr=fdLog)

        time.sleep(2)

        if cls._auths[suffix].poll() is not None:
            cls._auths[suffix].kill()
            sys.exit(cls._auths[suffix].returncode)

    @classmethod
    def generateRecursorConfig(cls, confdir):
        params = tuple([getattr(cls, param) for param in cls._config_params])
        if len(params):
            print(params)

        with open(os.path.join(confdir, 'recursor.conf'), 'w') as conf:
            conf.write("# Autogenerated by recursortests.py\n")
            conf.write(cls._config_template_default)
            conf.write("socket-dir=%s\n" % confdir)
            conf.write(cls._config_template % params)
            if cls._lua_config_file or cls._root_DS:
                luaconfpath = os.path.join(confdir, 'conffile.lua')
                with open(luaconfpath, 'w') as luaconf:
                    if cls._root_DS:
                        luaconf.write("addDS('.', '%s')" % cls._root_DS)
                    if cls._lua_config_file:
                        luaconf.write(cls._lua_config_file)
                conf.write("lua-config-file=%s" % luaconfpath)
            if cls._roothints:
                roothintspath = os.path.join(confdir, 'root.hints')
                with open(roothintspath, 'w') as roothints:
                    luaconf.write(cls._roothints)
                conf.write("hint-file=%s" % roothintspath)

    @classmethod
    def startRecursor(cls, confdir):
        print("Launching pdns_recursor..")
        recursorcmd = [os.environ['PDNSRECURSOR'],
                       '--config-dir=%s' % confdir,
                       '--local-port=%s' % cls._recursorPort]
        print(' '.join(recursorcmd))

        logFile = os.path.join(confdir, 'recursor.log')
        with open(logFile, 'w') as fdLog:
            cls._recursor = subprocess.Popen(recursorcmd, close_fds=True,
                                             stdout=fdLog, stderr=fdLog)

        if 'PDNSRECURSOR_FAST_TESTS' in os.environ:
            delay = 0.5
        else:
            delay = cls._recursorStartupDelay

        time.sleep(delay)

        if cls._recursor.poll() is not None:
            cls._recursor.kill()
            sys.exit(cls._recursor.returncode)

    @classmethod
    def setUpSockets(cls):
        print("Setting up UDP socket..")
        cls._sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        cls._sock.settimeout(2.0)
        cls._sock.connect(("127.0.0.1", cls._recursorPort))

    @classmethod
    def setUpClass(cls):

        cls.setUpSockets()

        confdir = os.path.join('configs', cls._confdir)

        cls.createConfigDir(confdir)

        if cls._launch_auths:
            for auth_suffix, zones in cls._auths_zones.items():
                cls.generateAuthConfig(confdir, auth_suffix, zones)
                cls.startAuth(confdir, auth_suffix)

        cls.generateRecursorConfig(confdir)
        cls.startRecursor(confdir)

        print("Launching tests..")

    @classmethod
    def tearDownClass(cls):
        if 'PDNSRECURSOR_FAST_TESTS' in os.environ:
            delay = 0.1
        else:
            delay = 1.0
        try:
            if cls._recursor:
                cls._recursor.terminate()
                if cls._recursor.poll() is None:
                    time.sleep(delay)
                    if cls._recursor.poll() is None:
                            cls._recursor.kill()
                    cls._recursor.wait()
        except OSError as e:
            if e.errno != errno.ESRCH:
                raise

        for _, auth in cls._auths.items():
            try:
                auth.terminate()
                if auth.poll() is None:
                    time.sleep(delay)
                    if auth.poll() is None:
                        auth.kill()
                    auth.wait()
            except OSError as e:
                if e.errno != errno.ESRCH:
                    raise

    @classmethod
    def sendUDPQuery(cls, query, timeout=2.0):
        if timeout:
            cls._sock.settimeout(timeout)

        try:
            cls._sock.send(query.to_wire())
            data = cls._sock.recv(4096)
        except socket.timeout:
            data = None
        finally:
            if timeout:
                cls._sock.settimeout(None)

        message = None
        if data:
            message = dns.message.from_wire(data)
        return message

    @classmethod
    def sendTCPQuery(cls, query, timeout=2.0):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if timeout:
            sock.settimeout(timeout)

        sock.connect(("127.0.0.1", cls._recursorPort))

        try:
            wire = query.to_wire()
            sock.send(struct.pack("!H", len(wire)))
            sock.send(wire)
            data = sock.recv(2)
            if data:
                (datalen,) = struct.unpack("!H", data)
                data = sock.recv(datalen)
        except socket.timeout as e:
            print("Timeout: %s" % (str(e)))
            data = None
        except socket.error as e:
            print("Network error: %s" % (str(e)))
            data = None
        finally:
            sock.close()

        message = None
        if data:
            message = dns.message.from_wire(data)
        return message

    def setUp(self):
        # This function is called before every tests
        return
