// !! This file has been generated by dnsdist-settings-generator.py, do not edit by hand!!
// START INCLUDE rust-pre-in.rs
use serde::{Deserialize, Serialize};

mod helpers;
use helpers::*;

// Suppresses "Deserialize unused" warning
#[derive(Deserialize, Serialize)]
struct UnusedStruct {}

#[derive(Debug)]
pub struct ValidationError {
    msg: String,
}

#[cxx::bridge(namespace = dnsdist::rust::settings)]
mod dnsdistsettings {
    #[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ResponseConfig {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        set_aa: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        set_ad: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        set_ra: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ttl: u32,
    }

    #[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SOAParams {
        serial: u32,
        refresh: u32,
        retry: u32,
        expire: u32,
        minimum: u32,
    }

    #[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SVCRecordAdditionalParams {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        value: String,
    }

    #[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SVCRecordParameters {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        mandatory_params: Vec<u16>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alpns: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ipv4_hints: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ipv6_hints: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        additional_params: Vec<SVCRecordAdditionalParams>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        target: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        port: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        priority: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        no_default_alpn: bool,
    }

    struct SharedDNSSelector {
        selector: SharedPtr<DNSSelector>,
    }

    struct SharedDNSAction {
        action: SharedPtr<DNSActionWrapper>,
    }

    struct SharedDNSResponseAction {
        action: SharedPtr<DNSResponseActionWrapper>,
    }
// END INCLUDE rust-pre-in.rs
    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct AllowActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Default)]
    struct ContinueActionConfiguration {
        name: String,
        action: SharedDNSAction,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DelayActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        msec: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DnstapLogActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        identity: String,
        logger_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DropActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetEDNSOptionActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: u32,
        data: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ERCodeActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        rcode: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HTTPStatusActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        status: u16,
        body: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        content_type: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KeyValueStoreLookupActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        kvs_name: String,
        lookup_key_name: String,
        destination_tag: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KeyValueStoreRangeLookupActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        kvs_name: String,
        lookup_key_name: String,
        destination_tag: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LogActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        file_name: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        binary: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        append: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        buffered: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        verbose_only: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        include_timestamp: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFIActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFIPerThreadActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct NegativeAndSOAActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        nxd: bool,
        zone: String,
        ttl: u32,
        mname: String,
        rname: String,
        soa_parameters: SOAParams,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        soa_in_authority: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct NoneActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PoolActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        pool_name: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        stop_processing: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QPSActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        limit: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QPSPoolActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        limit: u32,
        pool_name: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        stop_processing: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RCodeActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        rcode: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RemoteLogActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        logger_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_file: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        server_id: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ip_encrypt_key: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        export_tags: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        metas: Vec<ProtoBufMetaConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetAdditionalProxyProtocolValueActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        proxy_type: u8,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetDisableECSActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetDisableValidationActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetECSActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        ipv4: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ipv6: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetECSOverrideActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        override_existing: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetECSPrefixLengthActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        ipv4: u16,
        ipv6: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetExtendedDNSErrorActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        info_code: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        extra_text: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetMacAddrActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetMaxReturnedTTLActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        max: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetNoRecurseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetProxyProtocolValuesActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        values: Vec<ProxyProtocolValueConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetSkipCacheActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetTagActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        tag: String,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetTempFailureCacheTTLActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        ttl: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SNMPTrapActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        reason: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SpoofActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        ips: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SpoofCNAMEActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        cname: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SpoofPacketActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        response: String,
        len: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SpoofRawActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        answers: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qtype_for_any: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SpoofSVCActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        parameters: Vec<SVCRecordParameters>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        vars: ResponseConfig,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TCActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TeeActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        rca: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lca: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        add_ecs: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        add_proxy_protocol: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct AllowResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ClearRecordTypesResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        types: Vec<u16>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DelayResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        msec: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DnstapLogResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        identity: String,
        logger_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DropResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LimitTTLResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        min: u32,
        max: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        types: Vec<u16>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LogResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        file_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        append: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        buffered: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        verbose_only: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        include_timestamp: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFIResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFIPerThreadResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RemoteLogResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        logger_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        alter_function_file: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        server_id: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ip_encrypt_key: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        include_cname: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        export_tags: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        export_extended_errors_to_meta: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        metas: Vec<ProtoBufMetaConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetExtendedDNSErrorResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        info_code: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        extra_text: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetMaxReturnedTTLResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        max: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetMaxTTLResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        max: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetMinTTLResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        min: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetReducedTTLResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        percentage: u8,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetSkipCacheResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SetTagResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        tag: String,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SNMPTrapResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        reason: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TCResponseActionConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct AllSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Default)]
    struct AndSelectorConfiguration {
        name: String,
        selectors: Vec<SharedDNSSelector>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ByNameSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        selector_name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DNSSECSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DSTPortSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        port: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct EDNSOptionSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        option_code: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct EDNSVersionSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        version: u8,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ERCodeSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        rcode: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HTTPHeaderSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        header: String,
        expression: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HTTPPathSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        path: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HTTPPathRegexSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        expression: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KeyValueStoreLookupSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        kvs_name: String,
        lookup_key_name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KeyValueStoreRangeLookupSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        kvs_name: String,
        lookup_key_name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFISelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LuaFFIPerThreadSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct MaxQPSSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        qps: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        burst: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct MaxQPSIPSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        qps: u32,
        #[serde(default = "crate::U8::<32>::value", skip_serializing_if = "crate::U8::<32>::is_equal")]
        ipv4_mask: u8,
        #[serde(default = "crate::U8::<64>::value", skip_serializing_if = "crate::U8::<64>::is_equal")]
        ipv6_mask: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        burst: u32,
        #[serde(default = "crate::U32::<300>::value", skip_serializing_if = "crate::U32::<300>::is_equal")]
        expiration: u32,
        #[serde(default = "crate::U32::<60>::value", skip_serializing_if = "crate::U32::<60>::is_equal")]
        cleanup_delay: u32,
        #[serde(default = "crate::U32::<10>::value", skip_serializing_if = "crate::U32::<10>::is_equal")]
        scan_fraction: u32,
        #[serde(default = "crate::U32::<10>::value", skip_serializing_if = "crate::U32::<10>::is_equal")]
        shards: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct NetmaskGroupSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        netmask_group_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        netmasks: Vec<String>,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        source: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        quiet: bool,
    }

    #[derive(Default)]
    struct NotSelectorConfiguration {
        name: String,
        selector: SharedDNSSelector,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct OpcodeSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        code: u8,
    }

    #[derive(Default)]
    struct OrSelectorConfiguration {
        name: String,
        selectors: Vec<SharedDNSSelector>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PayloadSizeSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        comparison: String,
        size: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PoolAvailableSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        pool: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PoolOutstandingSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        pool: String,
        max_outstanding: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProbaSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        probability: f64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProxyProtocolValueSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        option_type: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        option_value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QClassSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qclass: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        numeric_value: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QNameSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        qname: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QNameLabelsCountSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        min_labels_count: u16,
        max_labels_count: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QNameSetSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        qnames: Vec<String>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QNameSuffixSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        suffixes: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        quiet: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QNameWireLengthSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        min: u16,
        max: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QTypeSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        qtype: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        numeric_value: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RCodeSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        rcode: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RDSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RE2SelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        expression: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RecordsCountSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        section: u8,
        minimum: u16,
        maximum: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RecordsTypeCountSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        section: u8,
        record_type: u16,
        minimum: u16,
        maximum: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RegexSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        expression: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SNISelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        server_name: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TagSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        tag: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TCPSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        tcp: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TrailingDataSelectorConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
    }

    #[derive(Default)]
    struct GlobalConfiguration {
        acl: Vec<String>,
        backends: Vec<BackendConfiguration>,
        binds: Vec<BindConfiguration>,
        cache_hit_response_rules: Vec<ResponseRuleConfiguration>,
        cache_inserted_response_rules: Vec<ResponseRuleConfiguration>,
        cache_miss_rules: Vec<QueryRuleConfiguration>,
        cache_settings: CacheSettingsConfiguration,
        console: ConsoleConfiguration,
        dynamic_rules: Vec<DynamicRulesConfiguration>,
        dynamic_rules_settings: DynamicRulesSettingsConfiguration,
        ebpf: EbpfConfiguration,
        edns_client_subnet: EdnsClientSubnetConfiguration,
        general: GeneralConfiguration,
        key_value_stores: KeyValueStoresConfiguration,
        load_balancing_policies: LoadBalancingPoliciesConfiguration,
        logging: LoggingConfiguration,
        metrics: MetricsConfiguration,
        packet_caches: Vec<PacketCacheConfiguration>,
        pools: Vec<PoolConfiguration>,
        proxy_protocol: ProxyProtocolConfiguration,
        query_count: QueryCountConfiguration,
        query_rules: Vec<QueryRuleConfiguration>,
        remote_logging: RemoteLoggingConfiguration,
        response_rules: Vec<ResponseRuleConfiguration>,
        ring_buffers: RingBuffersConfiguration,
        security_polling: SecurityPollingConfiguration,
        selectors: Vec<SharedDNSSelector>,
        self_answered_response_rules: Vec<ResponseRuleConfiguration>,
        snmp: SnmpConfiguration,
        tuning: TuningConfiguration,
        webserver: WebserverConfiguration,
        xfr_response_rules: Vec<ResponseRuleConfiguration>,
        xsk: Vec<XskConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct MetricsConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        carbon: Vec<CarbonConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct CarbonConfiguration {
        address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        #[serde(default = "crate::U32::<30>::value", skip_serializing_if = "crate::U32::<30>::is_equal")]
        interval: u32,
        #[serde(rename = "namespace", default, skip_serializing_if = "crate::is_default")]
        name_space: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        instance: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RemoteLoggingConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        protobuf_loggers: Vec<ProtobufLoggerConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        dnstap_loggers: Vec<DnstapLoggerConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProtobufLoggerConfiguration {
        name: String,
        address: String,
        #[serde(default = "crate::U16::<2>::value", skip_serializing_if = "crate::U16::<2>::is_equal")]
        timeout: u16,
        #[serde(default = "crate::U64::<100>::value", skip_serializing_if = "crate::U64::<100>::is_equal")]
        max_queued_entries: u64,
        #[serde(default = "crate::U8::<1>::value", skip_serializing_if = "crate::U8::<1>::is_equal")]
        reconnect_wait_time: u8,
        #[serde(default = "crate::U64::<1>::value", skip_serializing_if = "crate::U64::<1>::is_equal")]
        connection_count: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DnstapLoggerConfiguration {
        name: String,
        transport: String,
        address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        buffer_hint: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        flush_timeout: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        input_queue_size: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        output_queue_size: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        queue_notify_threshold: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        reopen_interval: u64,
        #[serde(default = "crate::U64::<1>::value", skip_serializing_if = "crate::U64::<1>::is_equal")]
        connection_count: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProtoBufMetaConfiguration {
        key: String,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LmdbKvStoreConfiguration {
        name: String,
        file_name: String,
        database_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        no_lock: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct CdbKvStoreConfiguration {
        name: String,
        file_name: String,
        refresh_delay: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KvsLookupKeySourceIpConfiguration {
        name: String,
        #[serde(default = "crate::U8::<32>::value", skip_serializing_if = "crate::U8::<32>::is_equal")]
        v4_mask: u8,
        #[serde(default = "crate::U8::<128>::value", skip_serializing_if = "crate::U8::<128>::is_equal")]
        v6_mask: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        include_port: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KvsLookupKeyQnameConfiguration {
        name: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        wire_format: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KvsLookupKeySuffixConfiguration {
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        minimum_labels: u16,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        wire_format: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KvsLookupKeyTagConfiguration {
        name: String,
        tag: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KvsLookupKeysConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        source_ip_keys: Vec<KvsLookupKeySourceIpConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qname_keys: Vec<KvsLookupKeyQnameConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        suffix_keys: Vec<KvsLookupKeySuffixConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tag_keys: Vec<KvsLookupKeyTagConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct KeyValueStoresConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lmdb: Vec<LmdbKvStoreConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cdb: Vec<CdbKvStoreConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lookup_keys: KvsLookupKeysConfiguration,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct WebserverConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        listen_address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        password: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        api_key: String,
        #[serde(default = "crate::default_value_webserver_acl", skip_serializing_if = "crate::default_value_equal_webserver_acl")]
        acl: Vec<String>,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        api_requires_authentication: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        stats_require_authentication: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        dashboard_requires_authentication: bool,
        #[serde(default = "crate::U32::<100>::value", skip_serializing_if = "crate::U32::<100>::is_equal")]
        max_concurrent_connections: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        hash_plaintext_credentials: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        custom_headers: Vec<HttpCustomResponseHeaderConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        api_configuration_directory: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        api_read_write: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ConsoleConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        listen_address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key: String,
        #[serde(default = "crate::default_value_console_acl", skip_serializing_if = "crate::default_value_equal_console_acl")]
        acl: Vec<String>,
        #[serde(default = "crate::U32::<10000000>::value", skip_serializing_if = "crate::U32::<10000000>::is_equal")]
        maximum_output_size: u32,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        log_connections: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_concurrent_connections: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct EbpfMapConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_entries: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        pinned_path: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct EbpfConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ipv4: EbpfMapConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ipv6: EbpfMapConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cidr_ipv4: EbpfMapConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cidr_ipv6: EbpfMapConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qnames: EbpfMapConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        external: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct EdnsClientSubnetConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        override_existing: bool,
        #[serde(default = "crate::U8::<32>::value", skip_serializing_if = "crate::U8::<32>::is_equal")]
        source_prefix_v4: u8,
        #[serde(default = "crate::U8::<56>::value", skip_serializing_if = "crate::U8::<56>::is_equal")]
        source_prefix_v6: u8,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DynamicRulesSettingsConfiguration {
        #[serde(default = "crate::U64::<60>::value", skip_serializing_if = "crate::U64::<60>::is_equal")]
        purge_interval: u64,
        #[serde(default = "crate::default_value_dynamic_rules_settings_default_action", skip_serializing_if = "crate::default_value_equal_dynamic_rules_settings_default_action")]
        default_action: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DynamicRuleConfiguration {
        #[serde(rename = "type", )]
        rule_type: String,
        seconds: u32,
        action_duration: u32,
        comment: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        rate: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ratio: f64,
        #[serde(default = "crate::default_value_dynamic_rule_action", skip_serializing_if = "crate::default_value_equal_dynamic_rule_action")]
        action: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        warning_rate: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        warning_ratio: f64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tag_name: String,
        #[serde(default = "crate::default_value_dynamic_rule_tag_value", skip_serializing_if = "crate::default_value_equal_dynamic_rule_tag_value")]
        tag_value: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        visitor_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        visitor_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        visitor_function_file: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        rcode: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qtype: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        minimum_number_of_responses: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        minimum_global_cache_hit_ratio: f64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DynamicRulesConfiguration {
        name: String,
        #[serde(default = "crate::U8::<32>::value", skip_serializing_if = "crate::U8::<32>::is_equal")]
        mask_ipv4: u8,
        #[serde(default = "crate::U8::<64>::value", skip_serializing_if = "crate::U8::<64>::is_equal")]
        mask_ipv6: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        mask_port: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        exclude_ranges: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        include_ranges: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        exclude_domains: Vec<String>,
        rules: Vec<DynamicRuleConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct RingBuffersConfiguration {
        #[serde(default = "crate::U64::<10000>::value", skip_serializing_if = "crate::U64::<10000>::is_equal")]
        size: u64,
        #[serde(default = "crate::U64::<10>::value", skip_serializing_if = "crate::U64::<10>::is_equal")]
        shards: u64,
        #[serde(default = "crate::U64::<5>::value", skip_serializing_if = "crate::U64::<5>::is_equal")]
        lock_retries: u64,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        record_queries: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        record_responses: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingTlsCertificateKeyPairConfiguration {
        certificate: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        password: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingTlsConfiguration {
        #[serde(default = "crate::default_value_incoming_tls_provider", skip_serializing_if = "crate::default_value_equal_incoming_tls_provider")]
        provider: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        certificates: Vec<IncomingTlsCertificateKeyPairConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ciphers: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ciphers_tls_13: String,
        #[serde(default = "crate::default_value_incoming_tls_minimum_version", skip_serializing_if = "crate::default_value_equal_incoming_tls_minimum_version")]
        minimum_version: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ticket_key_file: String,
        #[serde(default = "crate::U32::<43200>::value", skip_serializing_if = "crate::U32::<43200>::is_equal")]
        tickets_keys_rotation_delay: u32,
        #[serde(default = "crate::U32::<5>::value", skip_serializing_if = "crate::U32::<5>::is_equal")]
        number_of_tickets_keys: u32,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        prefer_server_ciphers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        session_timeout: u32,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        session_tickets: bool,
        #[serde(default = "crate::U32::<20480>::value", skip_serializing_if = "crate::U32::<20480>::is_equal")]
        number_of_stored_sessions: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ocsp_response_files: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key_log_file: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        release_buffers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enable_renegotiation: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        async_mode: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ktls: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        read_ahead: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        proxy_protocol_outside_tls: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ignore_configuration_errors: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct OutgoingTlsConfiguration {
        #[serde(default = "crate::default_value_outgoing_tls_provider", skip_serializing_if = "crate::default_value_equal_outgoing_tls_provider")]
        provider: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        subject_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        subject_address: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        validate_certificate: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ca_store: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ciphers: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ciphers_tls_13: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key_log_file: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        release_buffers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enable_renegotiation: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ktls: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HttpCustomResponseHeaderConfiguration {
        key: String,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HttpResponsesMapConfiguration {
        expression: String,
        status: u16,
        content: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        headers: Vec<HttpCustomResponseHeaderConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingDohConfiguration {
        #[serde(default = "crate::default_value_incoming_doh_provider", skip_serializing_if = "crate::default_value_equal_incoming_doh_provider")]
        provider: String,
        #[serde(default = "crate::default_value_incoming_doh_paths", skip_serializing_if = "crate::default_value_equal_incoming_doh_paths")]
        paths: Vec<String>,
        #[serde(default = "crate::U64::<30>::value", skip_serializing_if = "crate::U64::<30>::is_equal")]
        idle_timeout: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        server_tokens: String,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        send_cache_control_headers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        keep_incoming_headers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        trust_forwarded_for_header: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        early_acl_drop: bool,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        exact_path_matching: bool,
        #[serde(default = "crate::U32::<1048576>::value", skip_serializing_if = "crate::U32::<1048576>::is_equal")]
        internal_pipe_buffer_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        custom_response_headers: Vec<HttpCustomResponseHeaderConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        responses_map: Vec<HttpResponsesMapConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingDoqConfiguration {
        #[serde(default = "crate::U64::<65535>::value", skip_serializing_if = "crate::U64::<65535>::is_equal")]
        max_concurrent_queries_per_connection: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingQuicConfiguration {
        #[serde(default = "crate::U64::<5>::value", skip_serializing_if = "crate::U64::<5>::is_equal")]
        idle_timeout: u64,
        #[serde(default = "crate::default_value_incoming_quic_congestion_control_algorithm", skip_serializing_if = "crate::default_value_equal_incoming_quic_congestion_control_algorithm")]
        congestion_control_algorithm: String,
        #[serde(default = "crate::U32::<1048576>::value", skip_serializing_if = "crate::U32::<1048576>::is_equal")]
        internal_pipe_buffer_size: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingDnscryptCertificateKeyPairConfiguration {
        certificate: String,
        key: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingDnscryptConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        provider_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        certificates: Vec<IncomingDnscryptCertificateKeyPairConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct OutgoingDohConfiguration {
        #[serde(default = "crate::default_value_outgoing_doh_path", skip_serializing_if = "crate::default_value_equal_outgoing_doh_path")]
        path: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        add_x_forwarded_headers: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct IncomingTcpConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_in_flight_queries: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        listen_queue_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        fast_open_queue_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_concurrent_connections: u32,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct BindConfiguration {
        listen_address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        reuseport: bool,
        #[serde(default = "crate::default_value_bind_protocol", skip_serializing_if = "crate::default_value_equal_bind_protocol")]
        protocol: String,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        threads: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        interface: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cpus: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enable_proxy_protocol: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tcp: IncomingTcpConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tls: IncomingTlsConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        doh: IncomingDohConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        doq: IncomingDoqConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        quic: IncomingQuicConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        dnscrypt: IncomingDnscryptConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        additional_addresses: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        xsk: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct OutgoingTcpConfiguration {
        #[serde(default = "crate::U16::<5>::value", skip_serializing_if = "crate::U16::<5>::is_equal")]
        retries: u16,
        #[serde(default = "crate::U16::<5>::value", skip_serializing_if = "crate::U16::<5>::is_equal")]
        connect_timeout: u16,
        #[serde(default = "crate::U16::<30>::value", skip_serializing_if = "crate::U16::<30>::is_equal")]
        send_timeout: u16,
        #[serde(default = "crate::U16::<30>::value", skip_serializing_if = "crate::U16::<30>::is_equal")]
        receive_timeout: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        fast_open: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProxyProtocolValueConfiguration {
        key: u8,
        value: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LazyHealthCheckConfiguration {
        #[serde(default = "crate::U16::<30>::value", skip_serializing_if = "crate::U16::<30>::is_equal")]
        interval: u16,
        #[serde(default = "crate::U16::<1>::value", skip_serializing_if = "crate::U16::<1>::is_equal")]
        min_sample_count: u16,
        #[serde(default = "crate::default_value_lazy_health_check_mode", skip_serializing_if = "crate::default_value_equal_lazy_health_check_mode")]
        mode: String,
        #[serde(default = "crate::U16::<100>::value", skip_serializing_if = "crate::U16::<100>::is_equal")]
        sample_size: u16,
        #[serde(default = "crate::U16::<20>::value", skip_serializing_if = "crate::U16::<20>::is_equal")]
        threshold: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        use_exponential_back_off: bool,
        #[serde(default = "crate::U16::<3600>::value", skip_serializing_if = "crate::U16::<3600>::is_equal")]
        max_back_off: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct HealthCheckConfiguration {
        #[serde(default = "crate::default_value_health_check_mode", skip_serializing_if = "crate::default_value_equal_health_check_mode")]
        mode: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        qname: String,
        #[serde(default = "crate::default_value_health_check_qclass", skip_serializing_if = "crate::default_value_equal_health_check_qclass")]
        qclass: String,
        #[serde(default = "crate::default_value_health_check_qtype", skip_serializing_if = "crate::default_value_equal_health_check_qtype")]
        qtype: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lua: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lua_file: String,
        #[serde(default = "crate::U16::<1000>::value", skip_serializing_if = "crate::U16::<1000>::is_equal")]
        timeout: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        set_cd: bool,
        #[serde(default = "crate::U8::<1>::value", skip_serializing_if = "crate::U8::<1>::is_equal")]
        max_failures: u8,
        #[serde(default = "crate::U8::<1>::value", skip_serializing_if = "crate::U8::<1>::is_equal")]
        rise: u8,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        interval: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        must_resolve: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        use_tcp: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        lazy: LazyHealthCheckConfiguration,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct OutgoingAutoUpgradeConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enabled: bool,
        #[serde(default = "crate::U32::<3600>::value", skip_serializing_if = "crate::U32::<3600>::is_equal")]
        interval: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        keep: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        pool: String,
        #[serde(default = "crate::U8::<7>::value", skip_serializing_if = "crate::U8::<7>::is_equal")]
        doh_key: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        use_lazy_health_check: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct BackendConfiguration {
        address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        id: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        name: String,
        protocol: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tls: OutgoingTlsConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        doh: OutgoingDohConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        use_client_subnet: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        use_proxy_protocol: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        queries_per_second: u32,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        order: u32,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        weight: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        udp_timeout: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        pools: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tcp: OutgoingTcpConfiguration,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        ip_bind_addr_no_port: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        health_checks: HealthCheckConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        source: String,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        sockets: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        disable_zero_scope: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        reconnect_on_up: bool,
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        max_in_flight: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tcp_only: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        auto_upgrade: OutgoingAutoUpgradeConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_concurrent_tcp_connections: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        proxy_protocol_advertise_tls: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        mac_address: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cpus: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        xsk: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TuningConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        doh: DohTuningConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tcp: TcpTuningConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tls: TlsTuningConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        udp: UdpTuningConfiguration,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TcpTuningConfiguration {
        #[serde(default = "crate::U32::<10>::value", skip_serializing_if = "crate::U32::<10>::is_equal")]
        worker_threads: u32,
        #[serde(default = "crate::U32::<2>::value", skip_serializing_if = "crate::U32::<2>::is_equal")]
        receive_timeout: u32,
        #[serde(default = "crate::U32::<2>::value", skip_serializing_if = "crate::U32::<2>::is_equal")]
        send_timeout: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_queries_per_connection: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_connection_duration: u64,
        #[serde(default = "crate::U64::<10000>::value", skip_serializing_if = "crate::U64::<10000>::is_equal")]
        max_queued_connections: u64,
        #[serde(default = "crate::U32::<1048576>::value", skip_serializing_if = "crate::U32::<1048576>::is_equal")]
        internal_pipe_buffer_size: u32,
        #[serde(default = "crate::U64::<300>::value", skip_serializing_if = "crate::U64::<300>::is_equal")]
        outgoing_max_idle_time: u64,
        #[serde(default = "crate::U64::<60>::value", skip_serializing_if = "crate::U64::<60>::is_equal")]
        outgoing_cleanup_interval: u64,
        #[serde(default = "crate::U64::<10>::value", skip_serializing_if = "crate::U64::<10>::is_equal")]
        outgoing_max_idle_connection_per_backend: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_connections_per_client: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        fast_open_key: String,
        #[serde(default = "crate::U8::<90>::value", skip_serializing_if = "crate::U8::<90>::is_equal")]
        connections_overload_threshold: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_connection_rate_per_client: u64,
        #[serde(default = "crate::U64::<5>::value", skip_serializing_if = "crate::U64::<5>::is_equal")]
        connection_rate_interval: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_tls_new_session_rate_per_client: u64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        max_tls_resumed_session_rate_per_client: u64,
        #[serde(default = "crate::U32::<50>::value", skip_serializing_if = "crate::U32::<50>::is_equal")]
        max_read_ios_per_query: u32,
        #[serde(default = "crate::U32::<60>::value", skip_serializing_if = "crate::U32::<60>::is_equal")]
        ban_duration_for_exceeding_max_read_ios_per_query: u32,
        #[serde(default = "crate::U32::<10>::value", skip_serializing_if = "crate::U32::<10>::is_equal")]
        ban_duration_for_exceeding_tcp_tls_rate: u32,
        #[serde(default = "crate::U8::<32>::value", skip_serializing_if = "crate::U8::<32>::is_equal")]
        connections_mask_v4: u8,
        #[serde(default = "crate::U8::<128>::value", skip_serializing_if = "crate::U8::<128>::is_equal")]
        connections_mask_v6: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        connections_mask_v4_port: u8,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct UdpTuningConfiguration {
        #[serde(default = "crate::U32::<1>::value", skip_serializing_if = "crate::U32::<1>::is_equal")]
        messages_per_round: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        send_buffer_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        receive_buffer_size: u32,
        #[serde(default = "crate::U32::<65535>::value", skip_serializing_if = "crate::U32::<65535>::is_equal")]
        max_outstanding_per_backend: u32,
        #[serde(default = "crate::U8::<2>::value", skip_serializing_if = "crate::U8::<2>::is_equal")]
        timeout: u8,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        randomize_outgoing_sockets_to_backend: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        randomize_ids_to_backend: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TlsEngineConfiguration {
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        default_string: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct TlsTuningConfiguration {
        #[serde(default = "crate::U16::<60>::value", skip_serializing_if = "crate::U16::<60>::is_equal")]
        outgoing_tickets_cache_cleanup_delay: u16,
        #[serde(default = "crate::U16::<600>::value", skip_serializing_if = "crate::U16::<600>::is_equal")]
        outgoing_tickets_cache_validity: u16,
        #[serde(default = "crate::U16::<20>::value", skip_serializing_if = "crate::U16::<20>::is_equal")]
        max_outgoing_tickets_per_backend: u16,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        providers: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        engines: Vec<TlsEngineConfiguration>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct DohTuningConfiguration {
        #[serde(default = "crate::U32::<10>::value", skip_serializing_if = "crate::U32::<10>::is_equal")]
        outgoing_worker_threads: u32,
        #[serde(default = "crate::U64::<300>::value", skip_serializing_if = "crate::U64::<300>::is_equal")]
        outgoing_max_idle_time: u64,
        #[serde(default = "crate::U64::<60>::value", skip_serializing_if = "crate::U64::<60>::is_equal")]
        outgoing_cleanup_interval: u64,
        #[serde(default = "crate::U64::<10>::value", skip_serializing_if = "crate::U64::<10>::is_equal")]
        outgoing_max_idle_connection_per_backend: u64,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct CacheSettingsConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        stale_entries_ttl: u32,
        #[serde(default = "crate::U16::<60>::value", skip_serializing_if = "crate::U16::<60>::is_equal")]
        cleaning_delay: u16,
        #[serde(default = "crate::U16::<100>::value", skip_serializing_if = "crate::U16::<100>::is_equal")]
        cleaning_percentage: u16,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SecurityPollingConfiguration {
        #[serde(default = "crate::U32::<3600>::value", skip_serializing_if = "crate::U32::<3600>::is_equal")]
        polling_interval: u32,
        #[serde(default = "crate::default_value_security_polling_suffix", skip_serializing_if = "crate::default_value_equal_security_polling_suffix")]
        suffix: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct StructuredLoggingConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enabled: bool,
        #[serde(default = "crate::default_value_structured_logging_level_prefix", skip_serializing_if = "crate::default_value_equal_structured_logging_level_prefix")]
        level_prefix: String,
        #[serde(default = "crate::default_value_structured_logging_time_format", skip_serializing_if = "crate::default_value_equal_structured_logging_time_format")]
        time_format: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LoggingConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        verbose: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        verbose_health_checks: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        verbose_log_destination: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        syslog_facility: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        structured: StructuredLoggingConfiguration,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct GeneralConfiguration {
        #[serde(default = "crate::U16::<1232>::value", skip_serializing_if = "crate::U16::<1232>::is_equal")]
        edns_udp_payload_size_self_generated_answers: u16,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        add_edns_to_self_generated_answers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        truncate_tc_answers: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        fixup_case: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        allow_empty_responses: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        drop_empty_queries: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        capabilities_to_retain: Vec<String>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PacketCacheConfiguration {
        name: String,
        size: u64,
        #[serde(default = "crate::Bool::<true>::value", skip_serializing_if = "crate::if_true")]
        deferrable_insert_lock: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        dont_age: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        keep_stale_data: bool,
        #[serde(default = "crate::U32::<3600>::value", skip_serializing_if = "crate::U32::<3600>::is_equal")]
        max_negative_ttl: u32,
        #[serde(default = "crate::U32::<86400>::value", skip_serializing_if = "crate::U32::<86400>::is_equal")]
        max_ttl: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        min_ttl: u32,
        #[serde(default = "crate::U32::<20>::value", skip_serializing_if = "crate::U32::<20>::is_equal")]
        shards: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        parse_ecs: bool,
        #[serde(default = "crate::U32::<60>::value", skip_serializing_if = "crate::U32::<60>::is_equal")]
        stale_ttl: u32,
        #[serde(default = "crate::U32::<60>::value", skip_serializing_if = "crate::U32::<60>::is_equal")]
        temporary_failure_ttl: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cookie_hashing: bool,
        #[serde(default = "crate::U32::<4096>::value", skip_serializing_if = "crate::U32::<4096>::is_equal")]
        maximum_entry_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        options_to_skip: Vec<String>,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct ProxyProtocolConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        acl: Vec<String>,
        #[serde(default = "crate::U32::<512>::value", skip_serializing_if = "crate::U32::<512>::is_equal")]
        maximum_payload_size: u32,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        apply_acl_to_proxied_clients: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct SnmpConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enabled: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        traps_enabled: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        daemon_socket: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct QueryCountConfiguration {
        #[serde(default, skip_serializing_if = "crate::is_default")]
        enabled: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        filter_function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        filter_function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        filter_function_file: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct PoolConfiguration {
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        packet_cache: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        policy: String,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct CustomLoadBalancingPolicyConfiguration {
        name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_name: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_code: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        function_file: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ffi: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        per_thread: bool,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct LoadBalancingPoliciesConfiguration {
        #[serde(default = "crate::default_value_load_balancing_policies_default_policy", skip_serializing_if = "crate::default_value_equal_load_balancing_policies_default_policy")]
        default_policy: String,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        servfail_on_no_server: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        round_robin_servfail_on_no_server: bool,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        weighted_balancing_factor: f64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        consistent_hashing_balancing_factor: f64,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        custom_policies: Vec<CustomLoadBalancingPolicyConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        hash_perturbation: u32,
    }

    struct QueryRuleConfiguration {
        name: String,
        uuid: String,
        selector: SharedDNSSelector,
        action: SharedDNSAction,
    }

    struct ResponseRuleConfiguration {
        name: String,
        uuid: String,
        selector: SharedDNSSelector,
        action: SharedDNSResponseAction,
    }

    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct XskConfiguration {
        name: String,
        interface: String,
        queues: u16,
        #[serde(default = "crate::U32::<65536>::value", skip_serializing_if = "crate::U32::<65536>::is_equal")]
        frames: u32,
        #[serde(default = "crate::default_value_xsk_map_path", skip_serializing_if = "crate::default_value_equal_xsk_map_path")]
        map_path: String,
    }


    /*
     * Functions callable from Rust (actions and selectors)
     */
    unsafe extern "C++" {
        fn getAllowAction(config: &AllowActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getContinueAction(config: &ContinueActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getDelayAction(config: &DelayActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getDnstapLogAction(config: &DnstapLogActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getDropAction(config: &DropActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetEDNSOptionAction(config: &SetEDNSOptionActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getERCodeAction(config: &ERCodeActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getHTTPStatusAction(config: &HTTPStatusActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getKeyValueStoreLookupAction(config: &KeyValueStoreLookupActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getKeyValueStoreRangeLookupAction(config: &KeyValueStoreRangeLookupActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getLogAction(config: &LogActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getLuaAction(config: &LuaActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getLuaFFIAction(config: &LuaFFIActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getLuaFFIPerThreadAction(config: &LuaFFIPerThreadActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getNegativeAndSOAAction(config: &NegativeAndSOAActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getNoneAction(config: &NoneActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getPoolAction(config: &PoolActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getQPSAction(config: &QPSActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getQPSPoolAction(config: &QPSPoolActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getRCodeAction(config: &RCodeActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getRemoteLogAction(config: &RemoteLogActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetAdditionalProxyProtocolValueAction(config: &SetAdditionalProxyProtocolValueActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetDisableECSAction(config: &SetDisableECSActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetDisableValidationAction(config: &SetDisableValidationActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetECSAction(config: &SetECSActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetECSOverrideAction(config: &SetECSOverrideActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetECSPrefixLengthAction(config: &SetECSPrefixLengthActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetExtendedDNSErrorAction(config: &SetExtendedDNSErrorActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetMacAddrAction(config: &SetMacAddrActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetMaxReturnedTTLAction(config: &SetMaxReturnedTTLActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetNoRecurseAction(config: &SetNoRecurseActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetProxyProtocolValuesAction(config: &SetProxyProtocolValuesActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetSkipCacheAction(config: &SetSkipCacheActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetTagAction(config: &SetTagActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSetTempFailureCacheTTLAction(config: &SetTempFailureCacheTTLActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSNMPTrapAction(config: &SNMPTrapActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSpoofAction(config: &SpoofActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSpoofCNAMEAction(config: &SpoofCNAMEActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSpoofPacketAction(config: &SpoofPacketActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSpoofRawAction(config: &SpoofRawActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getSpoofSVCAction(config: &SpoofSVCActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getTCAction(config: &TCActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getTeeAction(config: &TeeActionConfiguration) -> SharedPtr<DNSActionWrapper>;
        fn getAllowResponseAction(config: &AllowResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getClearRecordTypesResponseAction(config: &ClearRecordTypesResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getDelayResponseAction(config: &DelayResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getDnstapLogResponseAction(config: &DnstapLogResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getDropResponseAction(config: &DropResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getLimitTTLResponseAction(config: &LimitTTLResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getLogResponseAction(config: &LogResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getLuaResponseAction(config: &LuaResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getLuaFFIResponseAction(config: &LuaFFIResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getLuaFFIPerThreadResponseAction(config: &LuaFFIPerThreadResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getRemoteLogResponseAction(config: &RemoteLogResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetExtendedDNSErrorResponseAction(config: &SetExtendedDNSErrorResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetMaxReturnedTTLResponseAction(config: &SetMaxReturnedTTLResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetMaxTTLResponseAction(config: &SetMaxTTLResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetMinTTLResponseAction(config: &SetMinTTLResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetReducedTTLResponseAction(config: &SetReducedTTLResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetSkipCacheResponseAction(config: &SetSkipCacheResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSetTagResponseAction(config: &SetTagResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getSNMPTrapResponseAction(config: &SNMPTrapResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getTCResponseAction(config: &TCResponseActionConfiguration) -> SharedPtr<DNSResponseActionWrapper>;
        fn getAllSelector(config: &AllSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getAndSelector(config: &AndSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getByNameSelector(config: &ByNameSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getDNSSECSelector(config: &DNSSECSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getDSTPortSelector(config: &DSTPortSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getEDNSOptionSelector(config: &EDNSOptionSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getEDNSVersionSelector(config: &EDNSVersionSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getERCodeSelector(config: &ERCodeSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getHTTPHeaderSelector(config: &HTTPHeaderSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getHTTPPathSelector(config: &HTTPPathSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getHTTPPathRegexSelector(config: &HTTPPathRegexSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getKeyValueStoreLookupSelector(config: &KeyValueStoreLookupSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getKeyValueStoreRangeLookupSelector(config: &KeyValueStoreRangeLookupSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getLuaSelector(config: &LuaSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getLuaFFISelector(config: &LuaFFISelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getLuaFFIPerThreadSelector(config: &LuaFFIPerThreadSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getMaxQPSSelector(config: &MaxQPSSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getMaxQPSIPSelector(config: &MaxQPSIPSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getNetmaskGroupSelector(config: &NetmaskGroupSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getNotSelector(config: &NotSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getOpcodeSelector(config: &OpcodeSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getOrSelector(config: &OrSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getPayloadSizeSelector(config: &PayloadSizeSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getPoolAvailableSelector(config: &PoolAvailableSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getPoolOutstandingSelector(config: &PoolOutstandingSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getProbaSelector(config: &ProbaSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getProxyProtocolValueSelector(config: &ProxyProtocolValueSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQClassSelector(config: &QClassSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQNameSelector(config: &QNameSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQNameLabelsCountSelector(config: &QNameLabelsCountSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQNameSetSelector(config: &QNameSetSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQNameSuffixSelector(config: &QNameSuffixSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQNameWireLengthSelector(config: &QNameWireLengthSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getQTypeSelector(config: &QTypeSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRCodeSelector(config: &RCodeSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRDSelector(config: &RDSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRE2Selector(config: &RE2SelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRecordsCountSelector(config: &RecordsCountSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRecordsTypeCountSelector(config: &RecordsTypeCountSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getRegexSelector(config: &RegexSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getSNISelector(config: &SNISelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getTagSelector(config: &TagSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getTCPSelector(config: &TCPSelectorConfiguration) -> SharedPtr<DNSSelector>;
        fn getTrailingDataSelector(config: &TrailingDataSelectorConfiguration) -> SharedPtr<DNSSelector>;
    }
// START INCLUDE rust-middle-in.rs
    /*
     * Functions callable from C++
     */
    extern "Rust" {
        fn from_yaml_string(str: &str) -> Result<GlobalConfiguration>;
    }
    /*
     * Functions callable from Rust
     */
    unsafe extern "C++" {
        include!("dnsdist-rust-bridge.hh");
        type DNSSelector;
        type DNSActionWrapper;
        type DNSResponseActionWrapper;
        fn registerProtobufLogger(config: &ProtobufLoggerConfiguration);
        fn registerDnstapLogger(config: &DnstapLoggerConfiguration);
        fn registerKVSObjects(config: &KeyValueStoresConfiguration);
    }
}

impl Default for dnsdistsettings::SharedDNSAction {
    fn default() -> dnsdistsettings::SharedDNSAction {
        dnsdistsettings::SharedDNSAction {
            action: cxx::SharedPtr::null(),
        }
    }
}

impl Default for dnsdistsettings::SharedDNSSelector {
    fn default() -> dnsdistsettings::SharedDNSSelector {
        dnsdistsettings::SharedDNSSelector {
            selector: cxx::SharedPtr::null(),
        }
    }
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct AndSelectorConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    selectors: Vec<Selector>,
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct OrSelectorConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    selectors: Vec<Selector>,
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct NotSelectorConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    selector: Box<Selector>,
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct ContinueActionConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    action: Box<Action>,
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct QueryRuleConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    name: String,
    #[serde(default, skip_serializing_if = "crate::is_default")]
    uuid: String,
    selector: Selector,
    action: Action,
}

impl QueryRuleConfigurationSerde {
  fn validate(&self) -> Result<(), ValidationError> {
    Ok(())
  }
}

#[derive(Default, Deserialize, Serialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct ResponseRuleConfigurationSerde {
    #[serde(default, skip_serializing_if = "crate::is_default")]
    name: String,
    #[serde(default, skip_serializing_if = "crate::is_default")]
    uuid: String,
    selector: Selector,
    action: ResponseAction,
}

impl ResponseRuleConfigurationSerde {
  fn validate(&self) -> Result<(), ValidationError> {
    Ok(())
  }
}
// END INCLUDE rust-middle-in.rs
    #[derive(Deserialize, Serialize, Debug, PartialEq)]
    #[serde(deny_unknown_fields)]
    struct GlobalConfigurationSerde {
        #[serde(default = "crate::default_value_global_acl", skip_serializing_if = "crate::default_value_equal_global_acl")]
        acl: Vec<String>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        backends: Vec<dnsdistsettings::BackendConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        binds: Vec<dnsdistsettings::BindConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cache_hit_response_rules: Vec<ResponseRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cache_inserted_response_rules: Vec<ResponseRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cache_miss_rules: Vec<QueryRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        cache_settings: dnsdistsettings::CacheSettingsConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        console: dnsdistsettings::ConsoleConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        dynamic_rules: Vec<dnsdistsettings::DynamicRulesConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        dynamic_rules_settings: dnsdistsettings::DynamicRulesSettingsConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ebpf: dnsdistsettings::EbpfConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        edns_client_subnet: dnsdistsettings::EdnsClientSubnetConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        general: dnsdistsettings::GeneralConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        key_value_stores: dnsdistsettings::KeyValueStoresConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        load_balancing_policies: dnsdistsettings::LoadBalancingPoliciesConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        logging: dnsdistsettings::LoggingConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        metrics: dnsdistsettings::MetricsConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        packet_caches: Vec<dnsdistsettings::PacketCacheConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        pools: Vec<dnsdistsettings::PoolConfiguration>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        proxy_protocol: dnsdistsettings::ProxyProtocolConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        query_count: dnsdistsettings::QueryCountConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        query_rules: Vec<QueryRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        remote_logging: dnsdistsettings::RemoteLoggingConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        response_rules: Vec<ResponseRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        ring_buffers: dnsdistsettings::RingBuffersConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        security_polling: dnsdistsettings::SecurityPollingConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        selectors: Vec<Selector>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        self_answered_response_rules: Vec<ResponseRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        snmp: dnsdistsettings::SnmpConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        tuning: dnsdistsettings::TuningConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        webserver: dnsdistsettings::WebserverConfiguration,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        xfr_response_rules: Vec<ResponseRuleConfigurationSerde>,
        #[serde(default, skip_serializing_if = "crate::is_default")]
        xsk: Vec<dnsdistsettings::XskConfiguration>,
    }

#[derive(Default, Serialize, Deserialize, Debug, PartialEq)]
#[serde(tag = "type")]
enum Action {
    #[default]
    Default,
    Allow(dnsdistsettings::AllowActionConfiguration),
    Continue(ContinueActionConfigurationSerde),
    Delay(dnsdistsettings::DelayActionConfiguration),
    DnstapLog(dnsdistsettings::DnstapLogActionConfiguration),
    Drop(dnsdistsettings::DropActionConfiguration),
    SetEDNSOption(dnsdistsettings::SetEDNSOptionActionConfiguration),
    ERCode(dnsdistsettings::ERCodeActionConfiguration),
    HTTPStatus(dnsdistsettings::HTTPStatusActionConfiguration),
    KeyValueStoreLookup(dnsdistsettings::KeyValueStoreLookupActionConfiguration),
    KeyValueStoreRangeLookup(dnsdistsettings::KeyValueStoreRangeLookupActionConfiguration),
    Log(dnsdistsettings::LogActionConfiguration),
    Lua(dnsdistsettings::LuaActionConfiguration),
    LuaFFI(dnsdistsettings::LuaFFIActionConfiguration),
    LuaFFIPerThread(dnsdistsettings::LuaFFIPerThreadActionConfiguration),
    NegativeAndSOA(dnsdistsettings::NegativeAndSOAActionConfiguration),
    None(dnsdistsettings::NoneActionConfiguration),
    Pool(dnsdistsettings::PoolActionConfiguration),
    QPS(dnsdistsettings::QPSActionConfiguration),
    QPSPool(dnsdistsettings::QPSPoolActionConfiguration),
    RCode(dnsdistsettings::RCodeActionConfiguration),
    RemoteLog(dnsdistsettings::RemoteLogActionConfiguration),
    SetAdditionalProxyProtocolValue(dnsdistsettings::SetAdditionalProxyProtocolValueActionConfiguration),
    SetDisableECS(dnsdistsettings::SetDisableECSActionConfiguration),
    SetDisableValidation(dnsdistsettings::SetDisableValidationActionConfiguration),
    SetECS(dnsdistsettings::SetECSActionConfiguration),
    SetECSOverride(dnsdistsettings::SetECSOverrideActionConfiguration),
    SetECSPrefixLength(dnsdistsettings::SetECSPrefixLengthActionConfiguration),
    SetExtendedDNSError(dnsdistsettings::SetExtendedDNSErrorActionConfiguration),
    SetMacAddr(dnsdistsettings::SetMacAddrActionConfiguration),
    SetMaxReturnedTTL(dnsdistsettings::SetMaxReturnedTTLActionConfiguration),
    SetNoRecurse(dnsdistsettings::SetNoRecurseActionConfiguration),
    SetProxyProtocolValues(dnsdistsettings::SetProxyProtocolValuesActionConfiguration),
    SetSkipCache(dnsdistsettings::SetSkipCacheActionConfiguration),
    SetTag(dnsdistsettings::SetTagActionConfiguration),
    SetTempFailureCacheTTL(dnsdistsettings::SetTempFailureCacheTTLActionConfiguration),
    SNMPTrap(dnsdistsettings::SNMPTrapActionConfiguration),
    Spoof(dnsdistsettings::SpoofActionConfiguration),
    SpoofCNAME(dnsdistsettings::SpoofCNAMEActionConfiguration),
    SpoofPacket(dnsdistsettings::SpoofPacketActionConfiguration),
    SpoofRaw(dnsdistsettings::SpoofRawActionConfiguration),
    SpoofSVC(dnsdistsettings::SpoofSVCActionConfiguration),
    TC(dnsdistsettings::TCActionConfiguration),
    Tee(dnsdistsettings::TeeActionConfiguration),
}

#[derive(Default, Serialize, Deserialize, Debug, PartialEq)]
#[serde(tag = "type")]
enum ResponseAction {
    #[default]
    Default,
    Allow(dnsdistsettings::AllowResponseActionConfiguration),
    ClearRecordTypes(dnsdistsettings::ClearRecordTypesResponseActionConfiguration),
    Delay(dnsdistsettings::DelayResponseActionConfiguration),
    DnstapLog(dnsdistsettings::DnstapLogResponseActionConfiguration),
    Drop(dnsdistsettings::DropResponseActionConfiguration),
    LimitTTL(dnsdistsettings::LimitTTLResponseActionConfiguration),
    Log(dnsdistsettings::LogResponseActionConfiguration),
    Lua(dnsdistsettings::LuaResponseActionConfiguration),
    LuaFFI(dnsdistsettings::LuaFFIResponseActionConfiguration),
    LuaFFIPerThread(dnsdistsettings::LuaFFIPerThreadResponseActionConfiguration),
    RemoteLog(dnsdistsettings::RemoteLogResponseActionConfiguration),
    SetExtendedDNSError(dnsdistsettings::SetExtendedDNSErrorResponseActionConfiguration),
    SetMaxReturnedTTL(dnsdistsettings::SetMaxReturnedTTLResponseActionConfiguration),
    SetMaxTTL(dnsdistsettings::SetMaxTTLResponseActionConfiguration),
    SetMinTTL(dnsdistsettings::SetMinTTLResponseActionConfiguration),
    SetReducedTTL(dnsdistsettings::SetReducedTTLResponseActionConfiguration),
    SetSkipCache(dnsdistsettings::SetSkipCacheResponseActionConfiguration),
    SetTag(dnsdistsettings::SetTagResponseActionConfiguration),
    SNMPTrap(dnsdistsettings::SNMPTrapResponseActionConfiguration),
    TC(dnsdistsettings::TCResponseActionConfiguration),
}

#[derive(Default, Serialize, Deserialize, Debug, PartialEq)]
#[serde(tag = "type")]
enum Selector {
    #[default]
    Default,
    All(dnsdistsettings::AllSelectorConfiguration),
    And(AndSelectorConfigurationSerde),
    ByName(dnsdistsettings::ByNameSelectorConfiguration),
    DNSSEC(dnsdistsettings::DNSSECSelectorConfiguration),
    DSTPort(dnsdistsettings::DSTPortSelectorConfiguration),
    EDNSOption(dnsdistsettings::EDNSOptionSelectorConfiguration),
    EDNSVersion(dnsdistsettings::EDNSVersionSelectorConfiguration),
    ERCode(dnsdistsettings::ERCodeSelectorConfiguration),
    HTTPHeader(dnsdistsettings::HTTPHeaderSelectorConfiguration),
    HTTPPath(dnsdistsettings::HTTPPathSelectorConfiguration),
    HTTPPathRegex(dnsdistsettings::HTTPPathRegexSelectorConfiguration),
    KeyValueStoreLookup(dnsdistsettings::KeyValueStoreLookupSelectorConfiguration),
    KeyValueStoreRangeLookup(dnsdistsettings::KeyValueStoreRangeLookupSelectorConfiguration),
    Lua(dnsdistsettings::LuaSelectorConfiguration),
    LuaFFI(dnsdistsettings::LuaFFISelectorConfiguration),
    LuaFFIPerThread(dnsdistsettings::LuaFFIPerThreadSelectorConfiguration),
    MaxQPS(dnsdistsettings::MaxQPSSelectorConfiguration),
    MaxQPSIP(dnsdistsettings::MaxQPSIPSelectorConfiguration),
    NetmaskGroup(dnsdistsettings::NetmaskGroupSelectorConfiguration),
    Not(NotSelectorConfigurationSerde),
    Opcode(dnsdistsettings::OpcodeSelectorConfiguration),
    Or(OrSelectorConfigurationSerde),
    PayloadSize(dnsdistsettings::PayloadSizeSelectorConfiguration),
    PoolAvailable(dnsdistsettings::PoolAvailableSelectorConfiguration),
    PoolOutstanding(dnsdistsettings::PoolOutstandingSelectorConfiguration),
    Proba(dnsdistsettings::ProbaSelectorConfiguration),
    ProxyProtocolValue(dnsdistsettings::ProxyProtocolValueSelectorConfiguration),
    QClass(dnsdistsettings::QClassSelectorConfiguration),
    QName(dnsdistsettings::QNameSelectorConfiguration),
    QNameLabelsCount(dnsdistsettings::QNameLabelsCountSelectorConfiguration),
    QNameSet(dnsdistsettings::QNameSetSelectorConfiguration),
    QNameSuffix(dnsdistsettings::QNameSuffixSelectorConfiguration),
    QNameWireLength(dnsdistsettings::QNameWireLengthSelectorConfiguration),
    QType(dnsdistsettings::QTypeSelectorConfiguration),
    RCode(dnsdistsettings::RCodeSelectorConfiguration),
    RD(dnsdistsettings::RDSelectorConfiguration),
    RE2(dnsdistsettings::RE2SelectorConfiguration),
    RecordsCount(dnsdistsettings::RecordsCountSelectorConfiguration),
    RecordsTypeCount(dnsdistsettings::RecordsTypeCountSelectorConfiguration),
    Regex(dnsdistsettings::RegexSelectorConfiguration),
    SNI(dnsdistsettings::SNISelectorConfiguration),
    Tag(dnsdistsettings::TagSelectorConfiguration),
    TCP(dnsdistsettings::TCPSelectorConfiguration),
    TrailingData(dnsdistsettings::TrailingDataSelectorConfiguration),
}

impl Default for dnsdistsettings::MetricsConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::MetricsConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::CarbonConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::CarbonConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::RemoteLoggingConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::RemoteLoggingConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::ProtobufLoggerConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::ProtobufLoggerConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::DnstapLoggerConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::DnstapLoggerConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::ProtoBufMetaConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::ProtoBufMetaConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::LmdbKvStoreConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::LmdbKvStoreConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::CdbKvStoreConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::CdbKvStoreConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KvsLookupKeySourceIpConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KvsLookupKeySourceIpConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KvsLookupKeyQnameConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KvsLookupKeyQnameConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KvsLookupKeySuffixConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KvsLookupKeySuffixConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KvsLookupKeyTagConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KvsLookupKeyTagConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KvsLookupKeysConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KvsLookupKeysConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::KeyValueStoresConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::KeyValueStoresConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for webserver_acl
fn default_value_webserver_acl() -> Vec<String> {
    vec![
        String::from("127.0.0.1"),
        String::from("::1"),
    ]
}
fn default_value_equal_webserver_acl(value: &Vec<String>) -> bool {
    let def = default_value_webserver_acl();
    &def == value
}


impl Default for dnsdistsettings::WebserverConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::WebserverConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for console_acl
fn default_value_console_acl() -> Vec<String> {
    vec![
        String::from("127.0.0.1"),
        String::from("::1"),
    ]
}
fn default_value_equal_console_acl(value: &Vec<String>) -> bool {
    let def = default_value_console_acl();
    &def == value
}


impl Default for dnsdistsettings::ConsoleConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::ConsoleConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::EbpfMapConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::EbpfMapConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::EbpfConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::EbpfConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::EdnsClientSubnetConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::EdnsClientSubnetConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for dynamic_rules_settings_default_action
fn default_value_dynamic_rules_settings_default_action() -> String {
    String::from("Drop")
}
fn default_value_equal_dynamic_rules_settings_default_action(value: &str)-> bool {
    value == default_value_dynamic_rules_settings_default_action()
}


impl Default for dnsdistsettings::DynamicRulesSettingsConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::DynamicRulesSettingsConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for dynamic_rule_action
fn default_value_dynamic_rule_action() -> String {
    String::from("drop")
}
fn default_value_equal_dynamic_rule_action(value: &str)-> bool {
    value == default_value_dynamic_rule_action()
}


// DEFAULT HANDLING for dynamic_rule_tag_value
fn default_value_dynamic_rule_tag_value() -> String {
    String::from("0")
}
fn default_value_equal_dynamic_rule_tag_value(value: &str)-> bool {
    value == default_value_dynamic_rule_tag_value()
}


impl Default for dnsdistsettings::DynamicRuleConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::DynamicRuleConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::DynamicRulesConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::DynamicRulesConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::RingBuffersConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::RingBuffersConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::IncomingTlsCertificateKeyPairConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingTlsCertificateKeyPairConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for incoming_tls_provider
fn default_value_incoming_tls_provider() -> String {
    String::from("OpenSSL")
}
fn default_value_equal_incoming_tls_provider(value: &str)-> bool {
    value == default_value_incoming_tls_provider()
}


// DEFAULT HANDLING for incoming_tls_minimum_version
fn default_value_incoming_tls_minimum_version() -> String {
    String::from("tls1.0")
}
fn default_value_equal_incoming_tls_minimum_version(value: &str)-> bool {
    value == default_value_incoming_tls_minimum_version()
}


impl Default for dnsdistsettings::IncomingTlsConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingTlsConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for outgoing_tls_provider
fn default_value_outgoing_tls_provider() -> String {
    String::from("OpenSSL")
}
fn default_value_equal_outgoing_tls_provider(value: &str)-> bool {
    value == default_value_outgoing_tls_provider()
}


impl Default for dnsdistsettings::OutgoingTlsConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::OutgoingTlsConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::HttpCustomResponseHeaderConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::HttpCustomResponseHeaderConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::HttpResponsesMapConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::HttpResponsesMapConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for incoming_doh_provider
fn default_value_incoming_doh_provider() -> String {
    String::from("nghttp2")
}
fn default_value_equal_incoming_doh_provider(value: &str)-> bool {
    value == default_value_incoming_doh_provider()
}


// DEFAULT HANDLING for incoming_doh_paths
fn default_value_incoming_doh_paths() -> Vec<String> {
    vec![
        String::from("/dns-query"),
    ]
}
fn default_value_equal_incoming_doh_paths(value: &Vec<String>) -> bool {
    let def = default_value_incoming_doh_paths();
    &def == value
}


impl Default for dnsdistsettings::IncomingDohConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingDohConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::IncomingDoqConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingDoqConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for incoming_quic_congestion_control_algorithm
fn default_value_incoming_quic_congestion_control_algorithm() -> String {
    String::from("reno")
}
fn default_value_equal_incoming_quic_congestion_control_algorithm(value: &str)-> bool {
    value == default_value_incoming_quic_congestion_control_algorithm()
}


impl Default for dnsdistsettings::IncomingQuicConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingQuicConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::IncomingDnscryptCertificateKeyPairConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingDnscryptCertificateKeyPairConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::IncomingDnscryptConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingDnscryptConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for outgoing_doh_path
fn default_value_outgoing_doh_path() -> String {
    String::from("/dns-query")
}
fn default_value_equal_outgoing_doh_path(value: &str)-> bool {
    value == default_value_outgoing_doh_path()
}


impl Default for dnsdistsettings::OutgoingDohConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::OutgoingDohConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::IncomingTcpConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::IncomingTcpConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for bind_protocol
fn default_value_bind_protocol() -> String {
    String::from("Do53")
}
fn default_value_equal_bind_protocol(value: &str)-> bool {
    value == default_value_bind_protocol()
}


impl Default for dnsdistsettings::BindConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::BindConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::OutgoingTcpConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::OutgoingTcpConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::ProxyProtocolValueConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::ProxyProtocolValueConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for lazy_health_check_mode
fn default_value_lazy_health_check_mode() -> String {
    String::from("TimeoutOrServFail")
}
fn default_value_equal_lazy_health_check_mode(value: &str)-> bool {
    value == default_value_lazy_health_check_mode()
}


impl Default for dnsdistsettings::LazyHealthCheckConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::LazyHealthCheckConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for health_check_mode
fn default_value_health_check_mode() -> String {
    String::from("auto")
}
fn default_value_equal_health_check_mode(value: &str)-> bool {
    value == default_value_health_check_mode()
}


// DEFAULT HANDLING for health_check_qclass
fn default_value_health_check_qclass() -> String {
    String::from("IN")
}
fn default_value_equal_health_check_qclass(value: &str)-> bool {
    value == default_value_health_check_qclass()
}


// DEFAULT HANDLING for health_check_qtype
fn default_value_health_check_qtype() -> String {
    String::from("A")
}
fn default_value_equal_health_check_qtype(value: &str)-> bool {
    value == default_value_health_check_qtype()
}


impl Default for dnsdistsettings::HealthCheckConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::HealthCheckConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::OutgoingAutoUpgradeConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::OutgoingAutoUpgradeConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::BackendConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::BackendConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::TuningConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::TuningConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::TcpTuningConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::TcpTuningConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::UdpTuningConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::UdpTuningConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::TlsEngineConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::TlsEngineConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::TlsTuningConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::TlsTuningConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::DohTuningConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::DohTuningConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::CacheSettingsConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::CacheSettingsConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for security_polling_suffix
fn default_value_security_polling_suffix() -> String {
    String::from("secpoll.powerdns.com.")
}
fn default_value_equal_security_polling_suffix(value: &str)-> bool {
    value == default_value_security_polling_suffix()
}


impl Default for dnsdistsettings::SecurityPollingConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::SecurityPollingConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for structured_logging_level_prefix
fn default_value_structured_logging_level_prefix() -> String {
    String::from("prio")
}
fn default_value_equal_structured_logging_level_prefix(value: &str)-> bool {
    value == default_value_structured_logging_level_prefix()
}


// DEFAULT HANDLING for structured_logging_time_format
fn default_value_structured_logging_time_format() -> String {
    String::from("numeric")
}
fn default_value_equal_structured_logging_time_format(value: &str)-> bool {
    value == default_value_structured_logging_time_format()
}


impl Default for dnsdistsettings::StructuredLoggingConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::StructuredLoggingConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::LoggingConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::LoggingConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::GeneralConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::GeneralConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::PacketCacheConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::PacketCacheConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::ProxyProtocolConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::ProxyProtocolConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::SnmpConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::SnmpConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::QueryCountConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::QueryCountConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::PoolConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::PoolConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl Default for dnsdistsettings::CustomLoadBalancingPolicyConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::CustomLoadBalancingPolicyConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for load_balancing_policies_default_policy
fn default_value_load_balancing_policies_default_policy() -> String {
    String::from("leastOutstanding")
}
fn default_value_equal_load_balancing_policies_default_policy(value: &str)-> bool {
    value == default_value_load_balancing_policies_default_policy()
}


impl Default for dnsdistsettings::LoadBalancingPoliciesConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::LoadBalancingPoliciesConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for xsk_map_path
fn default_value_xsk_map_path() -> String {
    String::from("/sys/fs/bpf/dnsdist/xskmap")
}
fn default_value_equal_xsk_map_path(value: &str)-> bool {
    value == default_value_xsk_map_path()
}


impl Default for dnsdistsettings::XskConfiguration {
    fn default() -> Self {
        let deserialized: dnsdistsettings::XskConfiguration = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


// DEFAULT HANDLING for global_acl
fn default_value_global_acl() -> Vec<String> {
    vec![
        String::from("127.0.0.0/8"),
        String::from("10.0.0.0/8"),
        String::from("100.64.0.0/10"),
        String::from("169.254.0.0/16"),
        String::from("192.168.0.0/16"),
        String::from("172.16.0.0/12"),
        String::from("::1/128"),
        String::from("fc00::/7"),
        String::from("fe80::/10"),
    ]
}
fn default_value_equal_global_acl(value: &Vec<String>) -> bool {
    let def = default_value_global_acl();
    &def == value
}


impl Default for GlobalConfigurationSerde {
    fn default() -> Self {
        let deserialized: GlobalConfigurationSerde = serde_yaml::from_str("").unwrap();
        deserialized
    }
}


impl dnsdistsettings::MetricsConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.carbon {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::CarbonConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::RemoteLoggingConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.protobuf_loggers {
        sub_type.validate()?;
    }
        for sub_type in &self.dnstap_loggers {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::ProtobufLoggerConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::DnstapLoggerConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::LmdbKvStoreConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::CdbKvStoreConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::KvsLookupKeySourceIpConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::KvsLookupKeyQnameConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::KvsLookupKeySuffixConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::KvsLookupKeyTagConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::KvsLookupKeysConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.source_ip_keys {
        sub_type.validate()?;
    }
        for sub_type in &self.qname_keys {
        sub_type.validate()?;
    }
        for sub_type in &self.suffix_keys {
        sub_type.validate()?;
    }
        for sub_type in &self.tag_keys {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::KeyValueStoresConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.lmdb {
        sub_type.validate()?;
    }
        for sub_type in &self.cdb {
        sub_type.validate()?;
    }
        self.lookup_keys.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::WebserverConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.custom_headers {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::ConsoleConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::EbpfMapConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::EbpfConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.ipv4.validate()?;
        self.ipv6.validate()?;
        self.cidr_ipv4.validate()?;
        self.cidr_ipv6.validate()?;
        self.qnames.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::EdnsClientSubnetConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::DynamicRulesSettingsConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::DynamicRuleConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::DynamicRulesConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.rules {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::RingBuffersConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingTlsCertificateKeyPairConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingTlsConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.certificates {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::OutgoingTlsConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::HttpCustomResponseHeaderConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::HttpResponsesMapConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.headers {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::IncomingDohConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.custom_response_headers {
        sub_type.validate()?;
    }
        for sub_type in &self.responses_map {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::IncomingDoqConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingQuicConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingDnscryptCertificateKeyPairConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingDnscryptConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.certificates {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::OutgoingDohConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::IncomingTcpConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::BindConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.tcp.validate()?;
        self.tls.validate()?;
        self.doh.validate()?;
        self.doq.validate()?;
        self.quic.validate()?;
        self.dnscrypt.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::OutgoingTcpConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::LazyHealthCheckConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::HealthCheckConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.lazy.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::OutgoingAutoUpgradeConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::BackendConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.tls.validate()?;
        self.doh.validate()?;
        self.tcp.validate()?;
        self.health_checks.validate()?;
        self.auto_upgrade.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::TuningConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.doh.validate()?;
        self.tcp.validate()?;
        self.tls.validate()?;
        self.udp.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::TcpTuningConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::UdpTuningConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::TlsEngineConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::TlsTuningConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.engines {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::DohTuningConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::CacheSettingsConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::SecurityPollingConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::StructuredLoggingConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::LoggingConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        self.structured.validate()?;
        Ok(())
    }
}
impl dnsdistsettings::GeneralConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::PacketCacheConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::ProxyProtocolConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::SnmpConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::QueryCountConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::PoolConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::CustomLoadBalancingPolicyConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl dnsdistsettings::LoadBalancingPoliciesConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.custom_policies {
        sub_type.validate()?;
    }
        Ok(())
    }
}
impl dnsdistsettings::XskConfiguration {
    fn validate(&self) -> Result<(), ValidationError> {
        Ok(())
    }
}
impl GlobalConfigurationSerde {
    fn validate(&self) -> Result<(), ValidationError> {
        for sub_type in &self.backends {
        sub_type.validate()?;
    }
        for sub_type in &self.binds {
        sub_type.validate()?;
    }
        for sub_type in &self.cache_hit_response_rules {
        sub_type.validate()?;
    }
        for sub_type in &self.cache_inserted_response_rules {
        sub_type.validate()?;
    }
        for sub_type in &self.cache_miss_rules {
        sub_type.validate()?;
    }
        self.cache_settings.validate()?;
        self.console.validate()?;
        for sub_type in &self.dynamic_rules {
        sub_type.validate()?;
    }
        self.dynamic_rules_settings.validate()?;
        self.ebpf.validate()?;
        self.edns_client_subnet.validate()?;
        self.general.validate()?;
        self.key_value_stores.validate()?;
        self.load_balancing_policies.validate()?;
        self.logging.validate()?;
        self.metrics.validate()?;
        for sub_type in &self.packet_caches {
        sub_type.validate()?;
    }
        for sub_type in &self.pools {
        sub_type.validate()?;
    }
        self.proxy_protocol.validate()?;
        self.query_count.validate()?;
        for sub_type in &self.query_rules {
        sub_type.validate()?;
    }
        self.remote_logging.validate()?;
        for sub_type in &self.response_rules {
        sub_type.validate()?;
    }
        self.ring_buffers.validate()?;
        self.security_polling.validate()?;
        for sub_type in &self.self_answered_response_rules {
        sub_type.validate()?;
    }
        self.snmp.validate()?;
        self.tuning.validate()?;
        self.webserver.validate()?;
        for sub_type in &self.xfr_response_rules {
        sub_type.validate()?;
    }
        for sub_type in &self.xsk {
        sub_type.validate()?;
    }
        Ok(())
    }
}
fn get_one_action_from_serde(action: &Action) -> Option<dnsdistsettings::SharedDNSAction> {
    match action {
        Action::Default => {}
        Action::Allow(config) => {
                let tmp_action = dnsdistsettings::getAllowAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Continue(cont) => {
             let mut config: dnsdistsettings::ContinueActionConfiguration = Default::default();
             let new_action = get_one_action_from_serde(&*cont.action);
             if new_action.is_some() {
                 config.action = new_action.unwrap();
             }
             return Some(dnsdistsettings::SharedDNSAction {
                 action: dnsdistsettings::getContinueAction(&config),
             });
        }
        Action::Delay(config) => {
                let tmp_action = dnsdistsettings::getDelayAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::DnstapLog(config) => {
                let tmp_action = dnsdistsettings::getDnstapLogAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Drop(config) => {
                let tmp_action = dnsdistsettings::getDropAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetEDNSOption(config) => {
                let tmp_action = dnsdistsettings::getSetEDNSOptionAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::ERCode(config) => {
                let tmp_action = dnsdistsettings::getERCodeAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::HTTPStatus(config) => {
                let tmp_action = dnsdistsettings::getHTTPStatusAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::KeyValueStoreLookup(config) => {
                let tmp_action = dnsdistsettings::getKeyValueStoreLookupAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::KeyValueStoreRangeLookup(config) => {
                let tmp_action = dnsdistsettings::getKeyValueStoreRangeLookupAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Log(config) => {
                let tmp_action = dnsdistsettings::getLogAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Lua(config) => {
                let tmp_action = dnsdistsettings::getLuaAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::LuaFFI(config) => {
                let tmp_action = dnsdistsettings::getLuaFFIAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::LuaFFIPerThread(config) => {
                let tmp_action = dnsdistsettings::getLuaFFIPerThreadAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::NegativeAndSOA(config) => {
                let tmp_action = dnsdistsettings::getNegativeAndSOAAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::None(config) => {
                let tmp_action = dnsdistsettings::getNoneAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Pool(config) => {
                let tmp_action = dnsdistsettings::getPoolAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::QPS(config) => {
                let tmp_action = dnsdistsettings::getQPSAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::QPSPool(config) => {
                let tmp_action = dnsdistsettings::getQPSPoolAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::RCode(config) => {
                let tmp_action = dnsdistsettings::getRCodeAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::RemoteLog(config) => {
                let tmp_action = dnsdistsettings::getRemoteLogAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetAdditionalProxyProtocolValue(config) => {
                let tmp_action = dnsdistsettings::getSetAdditionalProxyProtocolValueAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetDisableECS(config) => {
                let tmp_action = dnsdistsettings::getSetDisableECSAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetDisableValidation(config) => {
                let tmp_action = dnsdistsettings::getSetDisableValidationAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetECS(config) => {
                let tmp_action = dnsdistsettings::getSetECSAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetECSOverride(config) => {
                let tmp_action = dnsdistsettings::getSetECSOverrideAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetECSPrefixLength(config) => {
                let tmp_action = dnsdistsettings::getSetECSPrefixLengthAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetExtendedDNSError(config) => {
                let tmp_action = dnsdistsettings::getSetExtendedDNSErrorAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetMacAddr(config) => {
                let tmp_action = dnsdistsettings::getSetMacAddrAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetMaxReturnedTTL(config) => {
                let tmp_action = dnsdistsettings::getSetMaxReturnedTTLAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetNoRecurse(config) => {
                let tmp_action = dnsdistsettings::getSetNoRecurseAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetProxyProtocolValues(config) => {
                let tmp_action = dnsdistsettings::getSetProxyProtocolValuesAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetSkipCache(config) => {
                let tmp_action = dnsdistsettings::getSetSkipCacheAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetTag(config) => {
                let tmp_action = dnsdistsettings::getSetTagAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SetTempFailureCacheTTL(config) => {
                let tmp_action = dnsdistsettings::getSetTempFailureCacheTTLAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SNMPTrap(config) => {
                let tmp_action = dnsdistsettings::getSNMPTrapAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Spoof(config) => {
                let tmp_action = dnsdistsettings::getSpoofAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SpoofCNAME(config) => {
                let tmp_action = dnsdistsettings::getSpoofCNAMEAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SpoofPacket(config) => {
                let tmp_action = dnsdistsettings::getSpoofPacketAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SpoofRaw(config) => {
                let tmp_action = dnsdistsettings::getSpoofRawAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::SpoofSVC(config) => {
                let tmp_action = dnsdistsettings::getSpoofSVCAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::TC(config) => {
                let tmp_action = dnsdistsettings::getTCAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
        Action::Tee(config) => {
                let tmp_action = dnsdistsettings::getTeeAction(&config);
                return Some(dnsdistsettings::SharedDNSAction {
                    action: tmp_action,
                });
            }
    }
    None
}
fn get_one_response_action_from_serde(action: &ResponseAction) -> Option<dnsdistsettings::SharedDNSResponseAction> {
    match action {
        ResponseAction::Default => {}
        ResponseAction::Allow(config) => {
                let tmp_action = dnsdistsettings::getAllowResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::ClearRecordTypes(config) => {
                let tmp_action = dnsdistsettings::getClearRecordTypesResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::Delay(config) => {
                let tmp_action = dnsdistsettings::getDelayResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::DnstapLog(config) => {
                let tmp_action = dnsdistsettings::getDnstapLogResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::Drop(config) => {
                let tmp_action = dnsdistsettings::getDropResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::LimitTTL(config) => {
                let tmp_action = dnsdistsettings::getLimitTTLResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::Log(config) => {
                let tmp_action = dnsdistsettings::getLogResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::Lua(config) => {
                let tmp_action = dnsdistsettings::getLuaResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::LuaFFI(config) => {
                let tmp_action = dnsdistsettings::getLuaFFIResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::LuaFFIPerThread(config) => {
                let tmp_action = dnsdistsettings::getLuaFFIPerThreadResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::RemoteLog(config) => {
                let tmp_action = dnsdistsettings::getRemoteLogResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetExtendedDNSError(config) => {
                let tmp_action = dnsdistsettings::getSetExtendedDNSErrorResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetMaxReturnedTTL(config) => {
                let tmp_action = dnsdistsettings::getSetMaxReturnedTTLResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetMaxTTL(config) => {
                let tmp_action = dnsdistsettings::getSetMaxTTLResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetMinTTL(config) => {
                let tmp_action = dnsdistsettings::getSetMinTTLResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetReducedTTL(config) => {
                let tmp_action = dnsdistsettings::getSetReducedTTLResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetSkipCache(config) => {
                let tmp_action = dnsdistsettings::getSetSkipCacheResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SetTag(config) => {
                let tmp_action = dnsdistsettings::getSetTagResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::SNMPTrap(config) => {
                let tmp_action = dnsdistsettings::getSNMPTrapResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
        ResponseAction::TC(config) => {
                let tmp_action = dnsdistsettings::getTCResponseAction(&config);
                return Some(dnsdistsettings::SharedDNSResponseAction {
                    action: tmp_action,
                });
            }
    }
    None
}
fn get_one_selector_from_serde(selector: &Selector) -> Option<dnsdistsettings::SharedDNSSelector> {
    match selector {
        Selector::Default => {}
        Selector::All(all) => {
            let tmp_selector = dnsdistsettings::getAllSelector(&all);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::And(and) => {
             let mut config: dnsdistsettings::AndSelectorConfiguration = Default::default();
             for sub_selector in &and.selectors {
                 let new_selector = get_one_selector_from_serde(&sub_selector);
                 if new_selector.is_some() {
                     config.selectors.push(new_selector.unwrap());
                 }
             }
             return Some(dnsdistsettings::SharedDNSSelector {
                 selector: dnsdistsettings::getAndSelector(&config),
             });
        }
        Selector::ByName(byname) => {
            let tmp_selector = dnsdistsettings::getByNameSelector(&byname);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::DNSSEC(dnssec) => {
            let tmp_selector = dnsdistsettings::getDNSSECSelector(&dnssec);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::DSTPort(dstport) => {
            let tmp_selector = dnsdistsettings::getDSTPortSelector(&dstport);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::EDNSOption(ednsoption) => {
            let tmp_selector = dnsdistsettings::getEDNSOptionSelector(&ednsoption);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::EDNSVersion(ednsversion) => {
            let tmp_selector = dnsdistsettings::getEDNSVersionSelector(&ednsversion);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::ERCode(ercode) => {
            let tmp_selector = dnsdistsettings::getERCodeSelector(&ercode);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::HTTPHeader(httpheader) => {
            let tmp_selector = dnsdistsettings::getHTTPHeaderSelector(&httpheader);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::HTTPPath(httppath) => {
            let tmp_selector = dnsdistsettings::getHTTPPathSelector(&httppath);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::HTTPPathRegex(httppathregex) => {
            let tmp_selector = dnsdistsettings::getHTTPPathRegexSelector(&httppathregex);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::KeyValueStoreLookup(keyvaluestorelookup) => {
            let tmp_selector = dnsdistsettings::getKeyValueStoreLookupSelector(&keyvaluestorelookup);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::KeyValueStoreRangeLookup(keyvaluestorerangelookup) => {
            let tmp_selector = dnsdistsettings::getKeyValueStoreRangeLookupSelector(&keyvaluestorerangelookup);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Lua(lua) => {
            let tmp_selector = dnsdistsettings::getLuaSelector(&lua);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::LuaFFI(luaffi) => {
            let tmp_selector = dnsdistsettings::getLuaFFISelector(&luaffi);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::LuaFFIPerThread(luaffiperthread) => {
            let tmp_selector = dnsdistsettings::getLuaFFIPerThreadSelector(&luaffiperthread);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::MaxQPS(maxqps) => {
            let tmp_selector = dnsdistsettings::getMaxQPSSelector(&maxqps);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::MaxQPSIP(maxqpsip) => {
            let tmp_selector = dnsdistsettings::getMaxQPSIPSelector(&maxqpsip);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::NetmaskGroup(netmaskgroup) => {
            let tmp_selector = dnsdistsettings::getNetmaskGroupSelector(&netmaskgroup);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Not(not) => {
             let mut config: dnsdistsettings::NotSelectorConfiguration = Default::default();
             let new_selector = get_one_selector_from_serde(&*not.selector);
             if new_selector.is_some() {
                 config.selector = new_selector.unwrap();
             }
             return Some(dnsdistsettings::SharedDNSSelector {
                 selector: dnsdistsettings::getNotSelector(&config),
             });
        }
        Selector::Opcode(opcode) => {
            let tmp_selector = dnsdistsettings::getOpcodeSelector(&opcode);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Or(or) => {
             let mut config: dnsdistsettings::OrSelectorConfiguration = Default::default();
             for sub_selector in &or.selectors {
                 let new_selector = get_one_selector_from_serde(&sub_selector);
                 if new_selector.is_some() {
                     config.selectors.push(new_selector.unwrap());
                 }
             }
             return Some(dnsdistsettings::SharedDNSSelector {
                 selector: dnsdistsettings::getOrSelector(&config),
             });
        }
        Selector::PayloadSize(payloadsize) => {
            let tmp_selector = dnsdistsettings::getPayloadSizeSelector(&payloadsize);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::PoolAvailable(poolavailable) => {
            let tmp_selector = dnsdistsettings::getPoolAvailableSelector(&poolavailable);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::PoolOutstanding(pooloutstanding) => {
            let tmp_selector = dnsdistsettings::getPoolOutstandingSelector(&pooloutstanding);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Proba(proba) => {
            let tmp_selector = dnsdistsettings::getProbaSelector(&proba);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::ProxyProtocolValue(proxyprotocolvalue) => {
            let tmp_selector = dnsdistsettings::getProxyProtocolValueSelector(&proxyprotocolvalue);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QClass(qclass) => {
            let tmp_selector = dnsdistsettings::getQClassSelector(&qclass);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QName(qname) => {
            let tmp_selector = dnsdistsettings::getQNameSelector(&qname);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QNameLabelsCount(qnamelabelscount) => {
            let tmp_selector = dnsdistsettings::getQNameLabelsCountSelector(&qnamelabelscount);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QNameSet(qnameset) => {
            let tmp_selector = dnsdistsettings::getQNameSetSelector(&qnameset);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QNameSuffix(qnamesuffix) => {
            let tmp_selector = dnsdistsettings::getQNameSuffixSelector(&qnamesuffix);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QNameWireLength(qnamewirelength) => {
            let tmp_selector = dnsdistsettings::getQNameWireLengthSelector(&qnamewirelength);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::QType(qtype) => {
            let tmp_selector = dnsdistsettings::getQTypeSelector(&qtype);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::RCode(rcode) => {
            let tmp_selector = dnsdistsettings::getRCodeSelector(&rcode);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::RD(rd) => {
            let tmp_selector = dnsdistsettings::getRDSelector(&rd);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::RE2(re2) => {
            let tmp_selector = dnsdistsettings::getRE2Selector(&re2);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::RecordsCount(recordscount) => {
            let tmp_selector = dnsdistsettings::getRecordsCountSelector(&recordscount);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::RecordsTypeCount(recordstypecount) => {
            let tmp_selector = dnsdistsettings::getRecordsTypeCountSelector(&recordstypecount);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Regex(regex) => {
            let tmp_selector = dnsdistsettings::getRegexSelector(&regex);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::SNI(sni) => {
            let tmp_selector = dnsdistsettings::getSNISelector(&sni);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::Tag(tag) => {
            let tmp_selector = dnsdistsettings::getTagSelector(&tag);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::TCP(tcp) => {
            let tmp_selector = dnsdistsettings::getTCPSelector(&tcp);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
        Selector::TrailingData(trailingdata) => {
            let tmp_selector = dnsdistsettings::getTrailingDataSelector(&trailingdata);
            return Some(dnsdistsettings::SharedDNSSelector {
                selector: tmp_selector,
            });
        }
    }
    None
}
// START INCLUDE rust-post-in.rs
fn get_selectors_from_serde(
    selectors_from_serde: &Vec<Selector>,
) -> Vec<dnsdistsettings::SharedDNSSelector> {
    let mut results: Vec<dnsdistsettings::SharedDNSSelector> = Vec::new();

    for rule in selectors_from_serde {
        let selector = get_one_selector_from_serde(&rule);
        if selector.is_some() {
            results.push(selector.unwrap());
        }
    }
    results
}

fn get_query_rules_from_serde(
    rules_from_serde: &Vec<QueryRuleConfigurationSerde>,
) -> Vec<dnsdistsettings::QueryRuleConfiguration> {
    let mut results: Vec<dnsdistsettings::QueryRuleConfiguration> = Vec::new();

    for rule in rules_from_serde {
        let selector = get_one_selector_from_serde(&rule.selector);
        let action = get_one_action_from_serde(&rule.action);
        if selector.is_some() && action.is_some() {
            results.push(dnsdistsettings::QueryRuleConfiguration {
              name: rule.name.clone(),
              uuid: rule.uuid.clone(),
              selector: selector.unwrap(),
              action: action.unwrap(),
            });
        }
    }
    results
}

fn get_response_rules_from_serde(
    rules_from_serde: &Vec<ResponseRuleConfigurationSerde>,
) -> Vec<dnsdistsettings::ResponseRuleConfiguration> {
    let mut results: Vec<dnsdistsettings::ResponseRuleConfiguration> = Vec::new();

    for rule in rules_from_serde {
        let selector = get_one_selector_from_serde(&rule.selector);
        let action = get_one_response_action_from_serde(&rule.action);
        if selector.is_some() && action.is_some() {
            results.push(dnsdistsettings::ResponseRuleConfiguration {
              name: rule.name.clone(),
              uuid: rule.uuid.clone(),
              selector: selector.unwrap(),
              action: action.unwrap(),
            });
        }
    }
    results
}

fn register_remote_loggers(
  config: &dnsdistsettings::RemoteLoggingConfiguration,
) {
  for logger in &config.protobuf_loggers {
    dnsdistsettings::registerProtobufLogger(&logger);
  }
  for logger in &config.dnstap_loggers {
    dnsdistsettings::registerDnstapLogger(&logger);
  }
}

fn get_global_configuration_from_serde(
    serde: GlobalConfigurationSerde,
) -> dnsdistsettings::GlobalConfiguration {
    let mut config: dnsdistsettings::GlobalConfiguration = Default::default();
    config.key_value_stores = serde.key_value_stores;
    config.webserver = serde.webserver;
    config.console = serde.console;
    config.edns_client_subnet = serde.edns_client_subnet;
    config.dynamic_rules_settings = serde.dynamic_rules_settings;
    config.dynamic_rules = serde.dynamic_rules;
    config.acl = serde.acl;
    config.ring_buffers = serde.ring_buffers;
    config.binds = serde.binds;
    config.backends = serde.backends;
    config.cache_settings = serde.cache_settings;
    config.security_polling = serde.security_polling;
    config.general = serde.general;
    config.packet_caches = serde.packet_caches;
    config.proxy_protocol = serde.proxy_protocol;
    config.snmp = serde.snmp;
    config.query_count = serde.query_count;
    config.load_balancing_policies = serde.load_balancing_policies;
    config.pools = serde.pools;
    config.metrics = serde.metrics;
    config.remote_logging = serde.remote_logging;
    config.tuning = serde.tuning;
    // this needs to be done before the rules so that they can refer to the loggers
    register_remote_loggers(&config.remote_logging);
    // this needs to be done before the rules so that they can refer to the KVS objects
    dnsdistsettings::registerKVSObjects(&config.key_value_stores);
    // this needs to be done BEFORE the rules so that they can refer to the selectors
    // by name
    config.selectors = get_selectors_from_serde(&serde.selectors);
    config.query_rules = get_query_rules_from_serde(&serde.query_rules);
    config.cache_miss_rules = get_query_rules_from_serde(&serde.cache_miss_rules);
    config.response_rules = get_response_rules_from_serde(&serde.response_rules);
    config.cache_hit_response_rules = get_response_rules_from_serde(&serde.cache_hit_response_rules);
    config.cache_inserted_response_rules = get_response_rules_from_serde(&serde.cache_inserted_response_rules);
    config.self_answered_response_rules = get_response_rules_from_serde(&serde.self_answered_response_rules);
    config.xfr_response_rules = get_response_rules_from_serde(&serde.xfr_response_rules);
    config
}

pub fn from_yaml_string(
    str: &str,
) -> Result<dnsdistsettings::GlobalConfiguration, serde_yaml::Error> {
    let serde_config: Result<GlobalConfigurationSerde, serde_yaml::Error> =
        serde_yaml::from_str(str);

    if !serde_config.is_err() {
      let validation_result = serde_config.as_ref().unwrap().validate();
      if let Err(e) = validation_result {
          println!("Error validating the configuration loaded from {}: {}", str, e);
      }
    }
    let config: dnsdistsettings::GlobalConfiguration =
        get_global_configuration_from_serde(serde_config?);
    return Ok(config);
}
// END INCLUDE rust-post-in.rs
