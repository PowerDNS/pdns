/*
    PowerDNS Versatile Database Driven Nameserver
    Copyright (C) 2002 - 2008  PowerDNS.COM BV

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License version 2 as published 
    by the Free Software Foundation

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include "arguments.hh"
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/compare.hpp>
#include <boost/algorithm/string/predicate.hpp>
#include <boost/foreach.hpp>
#include "namespaces.hh"
#include "logger.hh"
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>

const ArgvMap::param_t::const_iterator ArgvMap::begin()
{
  return params.begin();
}

const ArgvMap::param_t::const_iterator ArgvMap::end()
{
  return params.end();
}

string & ArgvMap::set(const string &var)
{
  return params[var];
}

bool ArgvMap::mustDo(const string &var)
{
  return ((*this)[var]!="no") && ((*this)[var]!="off");
}

vector<string>ArgvMap::list()
{
  vector<string> ret;
  for(map<string,string>::const_iterator i=params.begin();i!=params.end();++i)
    ret.push_back(i->first);
  return ret;
}

string ArgvMap::getHelp(const string &item)
{
  return helpmap[item];
}

string & ArgvMap::set(const string &var, const string &help)
{
  helpmap[var]=help;
  d_typeMap[var]="Parameter";
  return set(var);
}

void ArgvMap::setCmd(const string &var, const string &help)
{
  helpmap[var]=help;
  d_typeMap[var]="Command";
  set(var)="no";
}

string & ArgvMap::setSwitch(const string &var, const string &help)
{
  helpmap[var]=help;
  d_typeMap[var]="Switch";
  return set(var);
}


bool ArgvMap::contains(const string &var, const string &val)
{
  params_t::const_iterator param = params.find(var);
  if(param == params.end() || param->second.empty())  {
    return false;
  }
  vector<string> parts;
  vector<string>::const_iterator i;
  
  stringtok( parts, param->second, ", \t" );
  for( i = parts.begin(); i != parts.end(); i++ ) {
    if( *i == val ) {
      return true;
    }
  }

  return false;
}

string ArgvMap::helpstring(string prefix)
{
  if(prefix=="no")
    prefix="";
  
  string help;
  
  for(map<string,string>::const_iterator i=helpmap.begin();
      i!=helpmap.end();
      i++)
    {
      if(!prefix.empty() && i->first.find(prefix)) // only print items with prefix
        continue;

      help+="  --";
      help+=i->first;
      
      string type=d_typeMap[i->first];

      if(type=="Parameter")
        help+="=...";
      else if(type=="Switch")
        {
          help+=" | --"+i->first+"=yes";
          help+=" | --"+i->first+"=no";
        }
      

      help+="\n\t";
      help+=i->second;
      help+="\n";

    }
  return help;
}

string ArgvMap::configstring(bool current)
{
  string help;

  if (current)
    help="# Autogenerated configuration file based on running instance\n";
  else
    help="# Autogenerated configuration file template\n";
  
  for(map<string,string>::const_iterator i=helpmap.begin(); i!=helpmap.end(); i++) {
    if(d_typeMap[i->first]=="Command")
      continue;

    help+="#################################\n";
    help+="# ";
    help+=i->first;
    help+="\t";
    help+=i->second;
    help+="\n#\n";
    if (current) {
      help+=i->first+"="+params[i->first]+"\n\n";
    } else {
      help+="# "+i->first+"="+params[i->first]+"\n\n";
    }
  }
  return help;
}


const string & ArgvMap::operator[](const string &arg)
{
  if(!parmIsset(arg))
    throw ArgException(string("Undefined but needed argument: '")+arg+"'");


  return params[arg];
}

#ifndef WIN32
mode_t ArgvMap::asMode(const string &arg) 
{
  mode_t mode;
  const char *cptr_orig;
  char *cptr_ret = NULL;

  if(!parmIsset(arg))
   throw ArgException(string("Undefined but needed argument: '")+arg+"'");

  cptr_orig = params[arg].c_str();
  mode = static_cast<mode_t>(strtol(cptr_orig, &cptr_ret, 8));
  if (mode == 0 && cptr_ret == cptr_orig) 
    throw ArgException("'" + arg + string("' contains invalid octal mode"));
   return mode;
}

gid_t ArgvMap::asGid(const string &arg)
{
  gid_t gid;
  const char *cptr_orig;
  char *cptr_ret = NULL;

  if(!parmIsset(arg))
   throw ArgException(string("Undefined but needed argument: '")+arg+"'");

  cptr_orig = params[arg].c_str();
  gid = static_cast<gid_t>(strtol(cptr_orig, &cptr_ret, 0));
  if (gid == 0 && cptr_ret == cptr_orig) {
    // try to resolve
    struct group *group = getgrnam(params[arg].c_str());
    if (group == NULL)
     throw ArgException("'" + arg + string("' contains invalid group"));
    gid = group->gr_gid;
   }
   return gid;
}

uid_t ArgvMap::asUid(const string &arg)
{
  uid_t uid;
  const char *cptr_orig;
  char *cptr_ret = NULL;

  if(!parmIsset(arg))
   throw ArgException(string("Undefined but needed argument: '")+arg+"'");

  cptr_orig = params[arg].c_str();
  uid = static_cast<uid_t>(strtol(cptr_orig, &cptr_ret, 0));
  if (uid == 0 && cptr_ret == cptr_orig) {
    // try to resolve
    struct passwd *pwent = getpwnam(params[arg].c_str());
    if (pwent == NULL)
     throw ArgException("'" + arg + string("' contains invalid group"));
    uid = pwent->pw_uid;
   }
   return uid;
}
#endif

int ArgvMap::asNum(const string &arg)
{
  int retval;
  const char *cptr_orig;
  char *cptr_ret = NULL;

  if(!parmIsset(arg))
    throw ArgException(string("Undefined but needed argument: '")+arg+"'");

  // treat empty values as zeros
  if (params[arg].empty())
   return 0;

  cptr_orig = params[arg].c_str();
  retval = static_cast<int>(strtol(cptr_orig, &cptr_ret, 0));
  if (!retval && cptr_ret == cptr_orig)
   throw ArgException("'"+arg+string("' is not valid number"));

  return retval;
}

bool ArgvMap::isEmpty(const string &arg) 
{
   if(!parmIsset(arg))
    return true;
   return params[arg].empty();
}

double ArgvMap::asDouble(const string &arg)
{
  double retval;
  const char *cptr_orig;
  char *cptr_ret = NULL;

  if(!parmIsset(arg))
    throw ArgException(string("Undefined but needed argument: '")+arg+"'");

  if (params[arg].empty())
   return 0.0;

  cptr_orig = params[arg].c_str();
  retval = strtod(cptr_orig, &cptr_ret);
 
  if (retval == 0 && cptr_ret == cptr_orig)
   throw ArgException("'"+arg+string("' is not valid double"));

  return retval;
}

ArgvMap::ArgvMap()
{

}

bool ArgvMap::parmIsset(const string &var)
{
  return (params.find(var)!=params.end());
}

void ArgvMap::parseOne(const string &arg, const string &parseOnly, bool lax)
{
  string var, val;
  string::size_type pos;
  bool incremental = false;
  if(!arg.find("--") &&(pos=arg.find("+="))!=string::npos) // this is a --port+=25 case
    {
      var=arg.substr(2,pos-2);
      val=arg.substr(pos+2);
      incremental = true;
    }
  else if(!arg.find("--") &&(pos=arg.find("="))!=string::npos)  // this is a --port=25 case
    {
      var=arg.substr(2,pos-2);
      val=arg.substr(pos+1);
    }
  else if(!arg.find("--") && (arg.find("=")==string::npos))  // this is a --daemon case
    { 
      var=arg.substr(2);
      val="";
    }
  else if(arg[0]=='-')
    {
      var=arg.substr(1);
      val="";
    }
  else { // command 
    d_cmds.push_back(arg);
  }

  if(var!="" && (parseOnly.empty() || var==parseOnly)) {

    pos=val.find_first_not_of(" \t");  // strip leading whitespace
    if(pos && pos!=string::npos)
      val=val.substr(pos);
    if (!incremental && val.empty()) d_cleared.insert(var);
    if(parmIsset(var)) {
      if (incremental) {
         if (params[var].empty() && !d_cleared.count(var)) {
           throw ArgException("Incremental parameter '"+var+"' without a parent");
         }
         if (params[var].empty())
            params[var]=val;
         else
            params[var]+=", " + val; 
      } else {
         params[var]=val;
      }
    }
    else
      if(!lax)
        throw ArgException("Trying to set unexisting parameter '"+var+"'");
  }
}

const vector<string>&ArgvMap::getCommands()
{
  return d_cmds;
}

void ArgvMap::parse(int &argc, char **argv, bool lax)
{
  d_cmds.clear();
  d_cleared.clear();
  for(int n=1;n<argc;n++) {
    parseOne(argv[n],"",lax);
  }
}

void ArgvMap::preParse(int &argc, char **argv, const string &arg)
{
  for(int n=1;n<argc;n++) {
    string varval=argv[n];
    if(!varval.find("--"+arg))
      parseOne(argv[n]);
  }
}

bool ArgvMap::preParseFile(const char *fname, const string &arg, const string& theDefault)
{
  params[arg]=theDefault;

  ifstream f(fname);
  if(!f)
    return false;

  string line;
  string pline;
  string::size_type pos;

  while(getline(f,pline)) {
    trim_right(pline);
    
    if(pline[pline.size()-1]=='\\') {
      line+=pline.substr(0,pline.length()-1);
      continue;
    }
    else
      line+=pline;

    // strip everything after a #
    if((pos=line.find("#"))!=string::npos)
      line=line.substr(0,pos);

    // strip trailing spaces
    trim_right(line);

    // strip leading spaces
    if((pos=line.find_first_not_of(" \t\r\n"))!=string::npos)
      line=line.substr(pos);

    // gpgsql-basic-query=sdfsdfs dfsdfsdf sdfsdfsfd

    parseOne( string("--") + line, arg );
    line="";
  }

  return true;
}

bool ArgvMap::file(const char *fname, bool lax)
{
   return file(fname,lax,false);
}

bool ArgvMap::file(const char *fname, bool lax, bool included)
{
  ifstream f(fname);
  if(!f) {
    return false;
  }

  if (!parmIsset("include-dir"))  // inject include-dir
    set("include-dir","Directory to include configuration files from");

  string line;
  string pline;
  string::size_type pos;

  while(getline(f,pline)) {
    trim_right(pline);
    if(pline.empty())
      continue;

    if(pline[pline.size()-1]=='\\') {
      line+=pline.substr(0,pline.length()-1);

      continue;
    }
    else
      line+=pline;

    // strip everything after a #
    if((pos=line.find("#"))!=string::npos)
      line=line.substr(0,pos);

    // strip trailing spaces
    trim(line);

    parseOne(string("--")+line,"",lax);
    line="";
  }

  // handle include here (avoid re-include)
  if (!included && !params["include-dir"].empty()) {
      // rerun parser for all files
      struct stat st;
      DIR *dir;
      struct dirent *ent;
      char namebuf[PATH_MAX] = {0};

      // stat
      if (stat(params["include-dir"].c_str(), &st)) {
         L << Logger::Error << params["include-dir"] << " does not exist!" << std::endl;
         throw ArgException(params["include-dir"] + " does not exist!");
      }

      // wonder if it's accessible directory
      if (!S_ISDIR(st.st_mode)) {
         L << Logger::Error << params["include-dir"] << " is not a directory" << std::endl;
         throw ArgException(params["include-dir"] + " is not a directory");
      }

      if (!(dir = opendir(params["include-dir"].c_str()))) {
         L << Logger::Error << params["include-dir"] << " is not accessible" << std::endl;
         throw ArgException(params["include-dir"] + " is not accessible");
      }
      
      std::vector<std::string> extraConfigs;
      while((ent = readdir(dir)) != NULL) {
         if (ent->d_name[0] == '.') continue; // skip any dots
         if (boost::ends_with(ent->d_name, ".conf")) {
            // ensure it's readable file
            snprintf(namebuf, sizeof namebuf, "%s/%s", params["include-dir"].c_str(), ent->d_name);
            if (stat(namebuf, &st) || !S_ISREG(st.st_mode)) {
                L << Logger::Error << namebuf << " is not a file" << std::endl;
                throw ArgException(std::string(namebuf) + " does not exist!");
            }
            extraConfigs.push_back(std::string(namebuf));
         }
      }
      std::sort(extraConfigs.begin(), extraConfigs.end(), CIStringComparePOSIX());
      BOOST_FOREACH(const std::string& fn, extraConfigs) {
            if (!file(fn.c_str(), lax, true)) {
                L << Logger::Error << namebuf << " could not be parsed" << std::endl;
                throw ArgException(fn + " could not be parsed");
            }
      }
  }

  return true;
}
