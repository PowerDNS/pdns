#!/bin/bash -ex

PDNS=${PDNS:-../pdns/pdns_server}
PDNS2=${PDNS2:-../pdns/pdns_server}

tosql ()
{
	make -C ../pdns/backends/bind zone2sql > /dev/null
	../pdns/backends/bind/zone2sql --transactions --$1 --named-conf=./named.conf

}

bindwait ()
{
	check_process
	configname=$1
	domcount=$(grep -c zone named.conf)
	if [ ! -x ../pdns/pdns_control ]; then
		echo "No pdns_control found"
		exit 1
	fi
	loopcount=0

	while [ $loopcount -lt 20 ]; do
		sleep 10
		done=$( (../pdns/pdns_control --config-name=$configname --socket-dir=. --no-config bind-domain-status || true) | grep -c 'parsed into memory' || true )
		if [ $done = $domcount ]; then
			return
		fi
		let loopcount=loopcount+1
	done

	if [ $done != $domcount ]; then
		echo "Domain parsing failed" >> failed_tests
	fi
}

securezone ()
{
	local zone=$1
	local configname=$2
	if [ -n "$configname" ]
	then
		configname="--config-name=$configname"
	fi
	if [ "${zone: 0:16}" = "secure-delegated" ]
	then
		../pdns/pdnssec --config-dir=. $configname import-zone-key $zone $zone.key ksk 2>&1
		../pdns/pdnssec --config-dir=. $configname add-zone-key $zone 1024 zsk 2>&1
		keyid=`../pdns/pdnssec --config-dir=. $configname show-zone $zone | grep ZSK | cut -d' ' -f3`
		../pdns/pdnssec --config-dir=. $configname activate-zone-key $zone $keyid 2>&1
		../pdns/pdnssec --config-dir=. $configname add-zone-key $zone 1024 zsk 2>&1
		../pdns/pdnssec --config-dir=. $configname rectify-zone $zone 2>&1
	else
		../pdns/pdnssec --config-dir=. $configname secure-zone $zone 2>&1
	fi
}

check_process ()
{
	set +e
	loopcount=0
	while [ $loopcount -lt 5 ]; do
		sleep 1
		pids=$(cat pdns*.pid 2>/dev/null)
		if [ ! -z "$pids" ]; then
			kill -0 $pids >/dev/null 2>&1
			if [ $? -eq 0 ]; then
				set -e
				return
			fi
		fi
	let loopcount=loopcount+1
	done
	echo "PowerDNS did not start"
	exit 1
}

if [ ! -x $PDNS ]; then
	echo "$PDNS is not executable binary"
	exit 1
fi

if [ ! -x $PDNS2 ]; then
	echo "$PDNS2 is not executable binary"
	exit 1
fi

port=$1
[ -z "$port" ] && port=5300
context=$2
[ -z "$context" ] && context=bind-dnssec
wait=$3
[ -z "$wait" ] && wait=nowait
cachettl=$4
[ -z "$cachettl" ] && cachettl=0
spectest=$5

testsdir=.

if [ "$port" = help ] || [ "$context" = help ]
then
	set +x
	grep -v '^#' << '__EOF__'

Usage: ./start-test-stop <port> [<context>] [wait|nowait] [<cachettl>] [<specifictest>]

context is one of:
bind bind-dnssec bind-dnssec-nsec3 bind-dnssec-nsec3-optout bind-dnssec-nsec3-narrow
gmysql-nodnssec gmysql gmysql-nsec3 gmysql-nsec3-optout gmysql-nsec3-narrow
gpgsql-nodnssec gpgsql gpgsql-nsec3
gsqlite3-nodnssec gsqlite3 gsqlite3-nsec3
opendbx-sqlite3
tinydns
mydns
remotebackend-pipe remotebackend-unix remotebackend-http 
remotebackend-pipe-dnssec remotebackend-unix-dnssec remotebackend-http-dnssec
#remotebackend-pipe-nsec3 remotebackend-unix-nsec3 remotebackend-http-nsec3
#remotebackend-pipe-nsec3-narrow remotebackend-unix-nsec3-narrow remotebackend-http-nsec3-narrow

* Add -presigned to any gmysql test (except narrow) to
  test presigned operation

* Add 'wait' (literally) after the context to not kill
  pdns_server immediately after testing. 'nowait' will kill it.

* A cachettl can be supplied if you want to run tests with a
  ttl setting set. The default cachettl is 0.

* Specifictest can be used to run only one single test.
__EOF__
	exit 1
fi

make -C ../pdns sdig nsec3dig || exit 1
# Copy original zones because the test might modify them (well only the dyndns stuff, but let's make this work for others as well)
for zone in $(grep zone named.conf  | cut -f2 -d\")
do
	if [ -f $zone.orig ]
	then
		cp -f $zone.orig $zone
	fi
done

rm -f pdns*.pid
rm -f *_tests

presigned=no

if [ "${context: -10}" = "-presigned" ]
then
	presigned=yes
	port=$((port-100))
	context=${context%-presigned}
fi

optout=0

if [ "${context: -13}" = "-nsec3-optout" ]
then
	optout=1
fi


case $context in
		bind)
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=bind --bind-config=./named.conf                \
				--send-root-referral    \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config &
			skipreasons="nodnssec nodyndns"
			bindwait
			;;

		bind-dnssec | bind-dnssec-nsec3 | bind-dnssec-nsec3-optout | bind-dnssec-nsec3-narrow)
			rm -f dnssec.sqlite3
			../pdns/pdnssec --config-dir=. create-bind-db dnssec.sqlite3
			../pdns/pdnssec --config-dir=. import-tsig-key test hmac-md5 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys='

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone
				if [ $context = bind-dnssec-nsec3 ] || [ $context = bind-dnssec-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. set-nsec3 $zone "1 $optout 1 abcd" 2>&1
				elif [ $context = bind-dnssec-nsec3-narrow ]
				then
					../pdns/pdnssec --config-dir=. set-nsec3 $zone '1 1 1 abcd' narrow 2>&1
				fi
			done

			if [ $context = bind-dnssec-nsec3 ]
			then
				extracontexts="bind dnssec nsec3"
				skipreasons="nsec3 nodyndns"
			elif [ $context = bind-dnssec-nsec3-optout ]
			then
				extracontexts="bind dnssec nsec3 nsec3-optout"
				skipreasons="optout nodyndns"
			elif [ $context = bind-dnssec-nsec3-narrow ]
			then
				extracontexts="bind dnssec narrow"
				skipreasons="narrow nodyndns"
			else
				extracontexts="bind dnssec"
				skipreasons="nodyndns"
			fi

                        ../pdns/pdnssec --config-dir=. enable-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=bind --bind-config=./named.conf \
				--bind-dnssec-db=./dnssec.sqlite3 \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config &
			bindwait
			;;

		gmysql-nodnssec)
			[ -z "$GMYSQLDB" ] && GMYSQLDB=pdnstest
			[ -z "$GMYSQLUSER" ] && GMYSQLUSER=root
			[ -z "$GMYSQLHOST" ] && GMYSQLHOST=localhost
			[ -z "$GMYSQLPASSWD" ] && GMYSQLPASSWD=''

			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" --force drop "$GMYSQLDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" create "$GMYSQLDB"
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../pdns/no-dnssec.schema.mysql.sql

			tosql gmysql | mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB"

			cat > pdns-gmysql.conf << __EOF__
launch=gmysql
gmysql-dbname=$GMYSQLDB
gmysql-user=$GMYSQLUSER
gmysql-host=$GMYSQLHOST
gmysql-password=$GMYSQLPASSWD
__EOF__

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gmysql \
				--master --send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config \
				--gmysql-dbname="$GMYSQLDB" \
				--gmysql-user="$GMYSQLUSER" \
				--gmysql-host="$GMYSQLHOST" \
				--gmysql-password="$GMYSQLPASSWD" &
			skipreasons=nodnssec
			;;
		mydns)
			[ -z "$MYDNSDB" ] && MYDNSDB=pdnstest
			[ -z "$MYDNSUSER" ] && MYDNSUSER=root
			[ -z "$MYDNSHOST" ] && MYDNSHOST=localhost
			[ -z "$MYDNSPASSWD" ] && MYDNSPASSWD=''

			mysqladmin --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" --force drop "$MYDNSDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" create "$MYDNSDB"
			mysql --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" \
				"$MYDNSDB" < ../modules/mydnsbackend/schema.sql

			tosql mydns | grep -v 'double\.example\.com' | mysql --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" \
				"$MYDNSDB"

			cat > pdns-mydns.conf << __EOF__
launch=mydns
mydns-dbname=$MYDNSDB
mydns-user=$MYDNSUSER
mydns-host=$MYDNSHOST
mydns-password=$MYDNSPASSWD
__EOF__
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=mydns \
				--master --send-root-referral \
				--cache-ttl=0 --no-config \
				--mydns-rr-active=no --mydns-soa-active=no --mydns-use-minimal-ttl=no \
				--mydns-dbname="$MYDNSDB" \
				--mydns-user="$MYDNSUSER" \
				--mydns-host="$MYDNSHOST" \
				--mydns-password="$MYDNSPASSWD" &
			skipreasons="nodnssec noent nodyndns"
			;;

		gmysql | gmysql-nsec3 | gmysql-nsec3-optout |gmysql-nsec3-narrow)
			[ -z "$GMYSQLDB" ] && GMYSQLDB=pdnstest
			[ -z "$GMYSQLUSER" ] && GMYSQLUSER=root
			[ -z "$GMYSQLHOST" ] && GMYSQLHOST=localhost
			[ -z "$GMYSQLPASSWD" ] && GMYSQLPASSWD=''

			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" --force drop "$GMYSQLDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" create "$GMYSQLDB"
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../pdns/no-dnssec.schema.mysql.sql
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../pdns/dnssec.schema.mysql.sql

			tosql gmysql | mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB"

			cat > pdns-gmysql.conf << __EOF__
launch=gmysql
gmysql-dbname=$GMYSQLDB
gmysql-user=$GMYSQLUSER
gmysql-host=$GMYSQLHOST
gmysql-password=$GMYSQLPASSWD
gmysql-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gmysql
				if [ $context = gmysql-nsec3 ] || [ $context = gmysql-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gmysql set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
				elif [ $context = gmysql-nsec3-narrow ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gmysql set-nsec3 $zone '1 1 1 abcd' narrow 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
				fi
				

			done

                        ../pdns/pdnssec --config-dir=. --config-name=gmysql import-tsig-key test hmac-md5 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys='
			../pdns/pdnssec --config-dir=. --config-name=gmysql enable-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch --launch+=random --launch+=gmysql --launch+=random --gmysql-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config \
				--gmysql-dbname="$GMYSQLDB" \
				--gmysql-user="$GMYSQLUSER" \
				--gmysql-host="$GMYSQLHOST" \
				--gmysql-password="$GMYSQLPASSWD" &
			if [ $context = gmysql-nsec3 ]
			then
				extracontexts="dnssec nsec3"
				skipreasons="nsec3"
			elif [ $context = gmysql-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
				skipreasons="optout"
			elif [ $context = gmysql-nsec3-narrow ]
			then
				extracontexts="dnssec narrow"
				skipreasons="narrow"
			else
				extracontexts="dnssec"
			fi

			;;	
		gpgsql | gpgsql-nsec3 | gpgsql-nsec3-optout)
			[ -z "$GPGSQLDB" ] && GPGSQLDB=pdnstest
			[ -z "$GPGSQLUSER" ] && GPGSQLUSER=$(whoami)

			dropdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring dropdb failure
			createdb --user="$GPGSQLUSER" "$GPGSQLDB" || echo ignoring createdb failure # FIXME
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../pdns/no-dnssec.schema.pgsql.sql
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../pdns/dnssec.schema.pgsql.sql

			tosql gpgsql | psql --user="$GPGSQLUSER" "$GPGSQLDB" 2>&1 | uniq -c

			cat > pdns-gpgsql.conf << __EOF__
launch=gpgsql
gpgsql-dbname=$GPGSQLDB
gpgsql-user=$GPGSQLUSER
gpgsql-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gpgsql
				if [ $context = gpgsql-nsec3 ] || [ $context = gpgsql-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gpgsql set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gpgsql rectify-zone $zone 2>&1
				fi
			done

                        ../pdns/pdnssec --config-dir=. --config-name=gmysql import-tsig-key test hmac-md5 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys='
                        ../pdns/pdnssec --config-dir=. --config-name=gmysql enable-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gpgsql --gpgsql-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gpgsql-dbname="$GPGSQLDB" \
				--gpgsql-user="$GPGSQLUSER" &
			if [ $context = gpgsql-nsec3 ]
			then
				extracontexts="dnssec nsec3"
			elif [ $context = gpgsql-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
			elif [ $context = gpgsql-nsec3-narrow ]
			then
				extracontexts="dnssec narrow"
			else
				extracontexts="dnssec"
			fi
			skipreasons="nodyndns"

			;;
		gpgsql-nodnssec)
			[ -z "$GPGSQLDB" ] && GPGSQLDB=pdnstest
			[ -z "$GPGSQLUSER" ] && GPGSQLUSER=$(whoami)

			dropdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring mysqladmin drop failure
			createdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring mysqladmin drop failure
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../pdns/no-dnssec.schema.pgsql.sql

			tosql gpgsql | psql --user="$GPGSQLUSER" "$GPGSQLDB" 2>&1 | uniq -c

			cat > pdns-gpgsql.conf << __EOF__
launch=gpgsql
gpgsql-dbname=$GPGSQLDB
gpgsql-user=$GPGSQLUSER
__EOF__

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gpgsql rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gpgsql \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gpgsql-dbname="$GPGSQLDB" \
				--gpgsql-user="$GPGSQLUSER" &
			skipreasons="nodnssec nodyndns"
			;;	


		gsqlite3-nodnssec)
			rm -f pdns.sqlite3
			sqlite3 pdns.sqlite3 < ../pdns/no-dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns.sqlite3
			echo ANALYZE\; | sqlite3 pdns.sqlite3

			cat > pdns-gsqlite3.conf << __EOF__
launch=gsqlite3
gsqlite3-database=pdns.sqlite3
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gsqlite3 rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gsqlite3 \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gsqlite3-database=pdns.sqlite3 &
			skipreasons="nodnssec nodyndns"

			;;
		opendbx-sqlite3)
			rm -f pdns-opendbx.sqlite3
			sqlite3 pdns-opendbx.sqlite3 < ../pdns/no-dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns-opendbx.sqlite3
			sqlite3 pdns-opendbx.sqlite3 "ALTER TABLE domains ADD status CHARACTER(1) NOT NULL DEFAULT 'A'; \
				ALTER TABLE domains ADD auto_serial INTEGER DEFAULT 0;"
			echo ANALYZE\; | sqlite3 pdns-opendbx.sqlite3

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=opendbx \
				--send-root-referral \
				--cache-ttl=$cachettl --no-config \
				--opendbx-backend=sqlite3 --opendbx-host-read=./ --opendbx-host-write=./ \
				--opendbx-database=pdns-opendbx.sqlite3 &
			skipreasons="nodnssec noent nodyndns"

			;;									
		gsqlite3 | gsqlite3-nsec3 | gsqlite3-nsec3-optout)
			rm -f pdns.sqlite3
			sqlite3 pdns.sqlite3 < ../pdns/no-dnssec.schema.sqlite3.sql
			sqlite3 pdns.sqlite3 < ../pdns/dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns.sqlite3
			echo ANALYZE\; | sqlite3 pdns.sqlite3

			cat > pdns-gsqlite3.conf << __EOF__
launch=gsqlite3
gsqlite3-database=pdns.sqlite3
gsqlite3-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gsqlite3
				if [ $context = gsqlite3-nsec3 ] || [ $context = gsqlite3-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gsqlite3 set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gsqlite3 rectify-zone $zone 2>&1
				fi
			done

                        ../pdns/pdnssec --config-dir=. --config-name=gsqlite3 import-tsig-key test hmac-md5 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys='
                        ../pdns/pdnssec --config-dir=. --config-name=gsqlite3 enable-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gsqlite3 --gsqlite3-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gsqlite3-database=pdns.sqlite3 &
			if [ $context = gsqlite3-nsec3 ]
			then
				extracontexts="dnssec nsec3"
			elif [ $context = gsqlite3-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
			else
				extracontexts="dnssec"
			fi
			skipreasons="nodyndns"
			;;
		tinydns)
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=tinydns \
			 --cache-ttl=$cachettl --no-config \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--tinydns-dbfile=../modules/tinydnsbackend/data.cdb & 
			skipreasons="nodnssec noent nodyndns"
			;;
		remotebackend-*)
			remotetype=$(echo $context | cut -d- -f 2)
			remotesec=$(echo $context | cut -d- -f 3)
			narrow=$(echo $context | cut -d- -f 4)
						testsdir=../modules/remotebackend/regression-tests/

						# cleanup unbound-host.conf to avoid failures
						rm -f unbound-host.conf

			case $remotetype in
			http)
				connstr="http:url=http://localhost:62434/dns"
				rm -f remotebackend-server.log
				rm -f remotebackend-access.log
				$testsdir/http-backend.rb &
				echo $! > pdns-remotebackend.pid
				set +e
				# make sure it runs before continuing
				loopcount=0
				while [ $loopcount -lt 20 ]; do
				     res=$(curl http://localhost:62434/ping 2>/dev/null)
				     if [ "x$res" == "xpong" ]; then break; fi
				     sleep 1
				     let loopcount=loopcount+1
				done
				set -e
				;;
			unix)
				connstr="unix:path=/tmp/remote.socket"
				socat unix-listen:/tmp/remote.socket,fork exec:$testsdir/unix-backend.rb &
				echo $! > pdns-remotebackend.pid
				;;
			pipe)
				connstr="pipe:command=$testsdir/pipe-backend.rb"
				;;
			*)
				echo "Invalid usage"
				exit 1
				;;
			esac

			skipreasons="nodnssec nodyndns"

			if [ "$remotesec" = "nsec3" ]; then
				remotedosec="yes"
				if [ "$narrow" = "narrow" ]; then
					extracontexts="dnssec nsec3 narrow"
					skipreasons="narrow nsec3 nodyndns"
			else
					extracontexts="dnssec nsec3"
					skipreasons="nsec3 nodyndns"
				fi
							remote_add_param="--remote-dnssec=yes"
						else 
				if [ "$remotesec" = "dnssec" ]; then
					remotedosec="yes"
					remote_add_param="--remote-dnssec=yes"
					extracontexts="dnssec"
					skipreasons="nonsec3 nonarrow nodyndns"
				fi
			fi

			# generate pdns.conf for pdnssec
			cat > pdns-remote.conf <<EOF
launch=remote
remote-connection-string=$connstr
EOF

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=remote \
				--query-logging --loglevel=9 --cache-ttl=$cachettl --no-config \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--remote-connection-string="$connstr" $remote_add_param &
						
			echo "Setting up test database..."
			# setup test database
			rm -f $testsdir/remote.sqlite3
			sqlite3 $testsdir/remote.sqlite3 < $testsdir/test-schema.sql
			chmod 0666 $testsdir/remote.sqlite3
			if [ "$remotedosec" = "yes" ]; then
								echo "remote-dnssec=yes" >> pdns-remote.conf
								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.ksk ksk
								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.zsk.1 zsk
								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.zsk.2 zsk
								../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 1
								../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 2
								../pdns/pdnssec --config-dir=. --config-name=remote deactivate-zone-key example.com 3

								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.ksk ksk
								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.zsk.1 zsk
								../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.zsk.2 zsk
								../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 4
								../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 5
								../pdns/pdnssec --config-dir=. --config-name=remote deactivate-zone-key example.com 6

				if [ "$remotesec" = "nsec3" ]; then
					../pdns/pdnssec --config-dir=. --config-name=remote set-nsec3 example.com
										../pdns/pdnssec --config-dir=. --config-name=remote set-nsec3 up.example.com
				fi

			fi

			;;
		*)
			echo unknown context $context
			: > passed_tests
			echo 'unknown-context-'"$context" > failed_tests
			./toxml $context
			exit 1
esac

check_process

export port
export context
export extracontexts
export skipreasons
export testsdir
export optout

if [ $presigned = yes ]
then
        skipreasons="$skipreasons presigned nodyndns"
	if [ ${context:0:6} = gmysql ]
	then
		context=${context}-presigned
		[ -z "$GMYSQL2DB" ] && GMYSQL2DB=pdnstest2
		[ -z "$GMYSQL2USER" ] && GMYSQL2USER=root
		[ -z "$GMYSQL2HOST" ] && GMYSQL2HOST=localhost
		[ -z "$GMYSQL2PASSWD" ] && GMYSQL2PASSWD=''

		mysqladmin --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" --force drop "$GMYSQL2DB" \
			|| echo ignoring mysqladmin drop failure
		mysqladmin --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" create "$GMYSQL2DB"
		mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" < ../pdns/no-dnssec.schema.mysql.sql
		mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" < ../pdns/dnssec.schema.mysql.sql

		for zone in $(grep zone named.conf  | cut -f2 -d\" | tac)
		do
			mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" \
			-e "INSERT INTO domains (name, type, master) VALUES('$zone','SLAVE','127.0.0.1:$port')"
		done

                set +e
                echo $skipreasons | grep -q nodnssec
                if [ $? -ne 0 ]; then
			mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
	                "$GMYSQL2DB" \
	                -e "INSERT INTO tsigkeys (name, algorithm,secret) VALUES('test', 'hmac-md5', 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys=')"
        	        mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
	                "$GMYSQL2DB" \
	                -e "INSERT INTO domainmetadata (domain_id, kind, content) SELECT id, 'AXFR-MASTER-TSIG', 'test' FROM domains WHERE name = 'tsig.com'"
		fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=gmysql --gmysql-dnssec \
			--send-root-referral \
			--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
			--cache-ttl=$cachettl --query-cache-ttl=$cachettl --no-config --slave --retrieval-threads=4 \
			--gmysql-dbname="$GMYSQL2DB" \
			--gmysql-user="$GMYSQL2USER" \
			--gmysql-host="$GMYSQL2HOST" \
			--gmysql-password="$GMYSQL2PASSWD" \
			--config-name=gmysql2 |& egrep -v "update records set ordername|insert into records" &
		echo 'waiting for zones to be slaved'
		loopcount=0
		while [ $loopcount -lt 20 ]
		do
			sleep 10
			todo=$(mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQl2HOST" \
				   "$GMYSQL2DB" -ss -e 'SELECT COUNT(id) FROM domains WHERE last_check IS NULL')
			if [ $todo = 0 ]
			then
				break
			fi
			let loopcount=loopcount+1
		done
		if [ $todo -ne 0 ]; then 
			echo "AXFR FAILED" >> failed_tests
		fi
	elif [ ${context:0:8} = gsqlite3 ]
	then
		context=${context}-presigned
		rm -f pdns.sqlite31
		sqlite3 pdns.sqlite31 < ../pdns/no-dnssec.schema.sqlite3.sql
		sqlite3 pdns.sqlite31 < ../pdns/dnssec.schema.sqlite3.sql

		for zone in $(grep zone named.conf  | cut -f2 -d\" | tac)
		do
			sqlite3 pdns.sqlite31 "INSERT INTO domains (name, type, master) VALUES('$zone','SLAVE','127.0.0.1:$port');"
		done
                
                set +e
                echo $skipreasons | grep -q nodnssec
                if [ $? -ne 0 ]; then
	                sqlite3 pdns.sqlite31 "INSERT INTO tsigkeys (name,algorithm,secret) VALUES('test','hmac-md5', 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys=')"
        	        sqlite3 pdns.sqlite31 "INSERT INTO domainmetadata (domain_id, kind, content) SELECT id, 'AXFR-MASTER-TSIG', 'test' FROM domains WHERE name = 'tsig.com'"
		fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=gsqlite3 --gsqlite3-dnssec \
			--fancy-records --send-root-referral \
			--cache-ttl=0 --query-cache-ttl=0 --no-config --slave --retrieval-threads=4 \
			--gsqlite3-database=pdns.sqlite31 --gsqlite3-pragma-synchronous=0 \
			--config-name=gsqlite32 |& egrep -v "update records set ordername|insert into records" &
		echo 'waiting for zones to be slaved'
		set +e
		loopcount=0
		while [ $loopcount -lt 20 ]
		do
			sleep 10
			todo=$(sqlite3 pdns.sqlite31 'SELECT COUNT(id) FROM domains WHERE last_check IS NULL')
			if [ $todo -eq 0 ]
			then
				if [ $todo = 0 ]
				then
					break
				fi
			fi
			let loopcount=loopcount+1
		done
		if [ $todo -ne 0 ]; then
				echo "AXFR FAILED" >> failed_tests
		fi
		set -e
		sqlite3 pdns.sqlite31 ANALYZE;
	elif [ ${context:0:4} = bind ]
	then
		context=${context}-presigned
		sed -e 's/type master;/type slave;\n\tmasters { 127.0.0.1:'$port'; };/' -e 's/file "\([^"]\+\)/file "\1-slave/' < named.conf > named-slave.conf

		for zone in $(grep zone named.conf  | cut -f2 -d\")
		do
			rm -rf $zone-slave
		done
		
		rm -f dnssec-slave.sqlite3

		../pdns/pdnssec --config-dir=. create-bind-db dnssec-slave.sqlite3

		set +e
                echo $skipreasons | grep -q nodnssec
                if [ $? -ne 0 ]; then
                   sqlite3 dnssec-slave.sqlite3 "INSERT INTO tsigkeys (name, algorithm,secret) VALUES('test', 'hmac-md5', 'kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys=')"
                   sqlite3 dnssec-slave.sqlite3 "INSERT INTO domainmetadata (domain, kind, content) SELECT 'tsig.com', 'AXFR-MASTER-TSIG', 'test'"
                fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=bind --bind-config=./named-slave.conf --slave         \
			--send-root-referral --retrieval-threads=1  --config-name=bind-slave \
			--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
			--cache-ttl=$cachettl --no-config --bind-dnssec-db=./dnssec-slave.sqlite3 &
		echo 'waiting for zones to be loaded'
		bindwait bind-slave
	fi
fi

## TODO: give pdns a few seconds to startup or fail, then check if it did not fail
## TODO: give sdig a timeout
nameserver=127.0.0.1 ./runtests $spectest
./toxml
./totar
if [ "$wait" = "wait" ]
then
	echo tests done! push enter to terminate instance
	read l
fi
kill $(cat pdns*.pid)
rm pdns*.pid

if [ -s "./failed_tests" ]
then
	for t in `cat failed_tests`
	do
		echo $t
		cat $t/diff
	done
	exit 1
fi
