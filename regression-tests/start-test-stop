#!/bin/bash -ex

PDNS=${PDNS:-../pdns/pdns_server}
PDNS2=${PDNS2:-../pdns/pdns_server}

ALGORITHM=${ALGORITHM:="hmac-md5"}
KEY=${KEY:="kp4/24gyYsEzbuTVJRUMoqGFmN3LYgVDzJ/3oRSP7ys="}

MAKE=${MAKE:-make}

export ALGORITHM
export KEY

nsdfix ()
{
	sed -e 's/"A very .*"/"shorter"/' < test.com > test.com.nsd
	sed '/EUI/s/^/;/g' < example.com > example.com.nsd
	sed -e '/testnonzone\.com\./s/^/;/g' -e '/NZTEST\.COM\.NET\./s/^/;/g' < nztest.com > nztest.com.nsd
}

bindfix ()
{
	sed -e 's/"A very .*"/"shorter"/' < test.com > test.com.bind
	sed -e '/EUI/s/^/;/g' -e '/host\.\*\.sub/s/^/;/g' < example.com > example.com.bind
}

tonsd ()
{
	cat > nsd.conf << __EOF__
server:
	ip-address: 127.0.0.1@$port
	database: ./nsd.db
	difffile: ./ixfr.db
	xfrdfile: ./ixfr.state

	zonesdir: .
	username: ""

key:
	name: test
	algorithm: $ALGORITHM
	secret: "$KEY"
__EOF__

	rm -f K*
	rm -f *.nsd

	nsdfix

	for zone in $(grep zone named.conf  | cut -f2 -d\")
	do

		if [ -f $zone.nsd ]
		then
			zonefile=${zone}.nsd
		else
			zonefile=${zone}
		fi

		if [ "$1" != "unsigned" ]
		then
			if [ ! "${zone: 0:16}" = "secure-delegated" ]
			then
				ksk=$(ldns-keygen -r /dev/urandom -a RSASHA256 -k $zone)
			else
				ksk="secure-delegated.dnssec-parent.com"
			fi
			zsk=$(ldns-keygen -r /dev/urandom -a RSASHA256 $zone)
		fi

		case $1 in
			nsec)
				ldns-signzone -f ${zone}.signed ${zonefile} $ksk $zsk
				;;
			nsec3)
				ldns-signzone -n -a 1 -s abcd -t 1 -f ${zone}.signed ${zonefile} $ksk $zsk
				;;
			nsec3-optout)
				ldns-signzone -n -p -a 1 -s abcd -t 1 -f ${zone}.signed ${zonefile} $ksk $zsk
				if [ "$zone" = "dnssec-parent.com" ]
				then
					echo "insecure.dnssec-parent.com.	IN	NS	ns.insecure.dnssec-parent.com." >> ${zone}.signed
				fi
				;;
			unsigned)
				cp ${zonefile} ${zone}.signed
				;;
			*)
				echo 'tonsd called with wrong param'
				exit 1
		esac

		echo "" >> nsd.conf
		echo "zone:" >> nsd.conf
		echo "	name: \"${zone}\"" >> nsd.conf
		echo "	zonefile: \"${zone}.signed\"" >> nsd.conf
		if [ "${zone}" = "tsig.com" ]
		then
			echo "	provide-xfr: 0.0.0.0/0 test" >> nsd.conf
			echo "	provide-xfr: ::0/0 test" >> nsd.conf
		else
			echo "	provide-xfr: 0.0.0.0/0 NOKEY" >> nsd.conf
			echo "	provide-xfr: ::0/0 NOKEY" >> nsd.conf
		fi
	done
	nsdc -c nsd.conf rebuild
}



tobind ()
{
	cat > bind.conf << __EOF__
options {
	dnssec-enable yes;
	listen-on port $port { 127.0.0.1; };
	minimal-responses yes;
	pid-file "pdns.pid";
};

key test {
	algorithm $ALGORITHM;
	secret "$KEY";
};
__EOF__

	rm -f K*
	rm -f *.bind

	bindfix

	for zone in $(grep zone named.conf  | cut -f2 -d\")
	do

		if [ ! -f $zone.bind ]
		then
			cp $zone $zone.bind
		fi

		if [ "$1" != "unsigned" ]
		then
			if [ ! "${zone: 0:16}" = "secure-delegated" ]
			then
				ksk=$(dnssec-keygen -r/dev/urandom -f KSK -a RSASHA256 -b 2048 -n ZONE $zone)
			else
				cp secure-delegated.dnssec-parent.com.private  Ksecure-delegated.dnssec-parent.com.+008+54319.private
				cp secure-delegated.dnssec-parent.com.key  Ksecure-delegated.dnssec-parent.com.+008+54319.key
				ksk="Ksecure-delegated.dnssec-parent.com.+008+54319"
			fi
			zsk=$(dnssec-keygen -r/dev/urandom -a RSASHA256 -b 1024 -n ZONE $zone)

			echo "\$include $ksk.key ; KSK" >> $zone.bind
			echo "\$include $zsk.key ; ZSK" >> $zone.bind
		fi

		case $1 in
			nsec)
				dnssec-signzone -o $zone -f $zone.signed $zone.bind
				;;
			nsec3)
				dnssec-signzone -3 abcd -H 1 -o $zone -f $zone.signed $zone.bind
				;;
			nsec3-optout)
				dnssec-signzone -3 abcd -H 1 -A -o $zone -f $zone.signed $zone.bind
				if [ "$zone" = "dnssec-parent.com" ]
				then
					echo "insecure.dnssec-parent.com.	IN	NS	ns.insecure.dnssec-parent.com." >> ${zone}.signed
				fi
				;;
			unsigned)
				cp ${zone}.bind ${zone}.signed
				;;
			*)
				echo 'tonsd called with wrong param'
				exit 1
		esac

		echo "" >> bind.conf
		echo "zone \"${zone}\" {" >> bind.conf
		echo "	type master;" >> bind.conf
		if [ "${zone}" = "tsig.com" ]
		then
			echo "	allow-transfer { key test; none; };" >> bind.conf
		fi
		echo "	file \"${zone}.signed\";" >> bind.conf
		echo "};" >> bind.conf
	done
}



tosql ()
{
	${MAKE} -C ../pdns zone2sql > /dev/null
	../pdns/zone2sql --transactions --$1 --named-conf=./named.conf
}

bindwait ()
{
	check_process
	configname=$1
	domcount=$(grep -c ^zone named.conf)
	if [ ! -x ../pdns/pdns_control ]
	then
		echo "No pdns_control found"
		exit 1
	fi
	loopcount=0

	while [ $loopcount -lt 20 ]
	do
		sleep 5
		done=$( (../pdns/pdns_control --config-name=$configname --socket-dir=. --no-config bind-domain-status || true) | grep -c 'parsed into memory' || true )
		if [ $done = $domcount ]
		then
			return
		fi
		let loopcount=loopcount+1
	done

	if [ $done != $domcount ]
	then
		echo "Domain parsing failed" >> failed_tests
	fi
}

securezone ()
{
	local zone=$1
	local configname=$2
	if [ -n "$configname" ]
	then
		configname="--config-name=$configname"
	fi
	if [ "${zone: 0:16}" = "secure-delegated" ]
	then
		../pdns/pdnssec --config-dir=. $configname import-zone-key $zone $zone.private ksk 2>&1
		../pdns/pdnssec --config-dir=. $configname add-zone-key $zone 1024 zsk 2>&1
		keyid=`../pdns/pdnssec --config-dir=. $configname show-zone $zone | grep ZSK | cut -d' ' -f3`
		../pdns/pdnssec --config-dir=. $configname activate-zone-key $zone $keyid 2>&1
		../pdns/pdnssec --config-dir=. $configname rectify-zone $zone 2>&1
	else
		../pdns/pdnssec --config-dir=. $configname secure-zone $zone 2>&1
	fi
}

check_process ()
{
	set +e
	loopcount=0
	while [ $loopcount -lt 5 ]; do
		sleep 1
		pids=$(cat pdns*.pid 2>/dev/null)
		if [ ! -z "$pids" ]
		then
			kill -0 $pids >/dev/null 2>&1
			if [ $? -eq 0 ]
			then
				set -e
				return
			fi
		fi
	let loopcount=loopcount+1
	done
	echo "PowerDNS did not start"
	exit 1
}

if [ ! -x $PDNS ]
 then
	echo "$PDNS is not executable binary"
	exit 1
fi

if [ ! -x $PDNS2 ]
then
	echo "$PDNS2 is not executable binary"
	exit 1
fi

port=$1
[ -z "$port" ] && port=5300
context=$2
[ -z "$context" ] && context=bind-dnssec
wait=$3
[ -z "$wait" ] && wait=nowait
cachettl=$4
[ -z "$cachettl" ] && cachettl=0
spectest=$5

testsdir=.

if [ "$port" = help ] || [ "$context" = help ]
then
	set +x
	grep -v '^#' << '__EOF__'

Usage: ./start-test-stop <port> [<context>] [wait|nowait] [<cachettl>] [<specifictest>]

context is one of:
ext-nsd ext-nsd-nsec ext-nsd-nsec3 ext-bind ext-bind-nsec ext-bind-nsec3
bind bind-dnssec bind-dnssec-nsec3 bind-dnssec-nsec3-optout bind-dnssec-nsec3-narrow
gmysql-nodnssec gmysql gmysql-nsec3 gmysql-nsec3-optout gmysql-nsec3-narrow
gpgsql-nodnssec gpgsql gpgsql-nsec3
gsqlite3-nodnssec gsqlite3 gsqlite3-nsec3
opendbx-sqlite3
tinydns
mydns
remotebackend-pipe remotebackend-unix remotebackend-http 
remotebackend-pipe-dnssec remotebackend-unix-dnssec remotebackend-http-dnssec
#remotebackend-pipe-nsec3 remotebackend-unix-nsec3 remotebackend-http-nsec3
#remotebackend-pipe-nsec3-narrow remotebackend-unix-nsec3-narrow remotebackend-http-nsec3-narrow

* Add -presigned to any ext-nsd, ext-bind, bind, gmysql or gsqlite3 test (except narrow)
  to test presigned operation.

* Add -both to any bind or gmysql test (except narrow) to
  test normal and presigned operation.

* Add 'wait' (literally) after the context to not kill
  pdns_server immediately after testing. 'nowait' will kill it.

* A cachettl can be supplied if you want to run tests with a
  ttl setting set. The default cachettl is 0.

* Specifictest can be used to run only one single test.
__EOF__
	exit 1
fi

${MAKE} -C ../pdns sdig nsec3dig || exit 1
# Copy original zones because the test might modify them (well only the dyndns stuff, but let's make this work for others as well)
for zone in $(grep zone named.conf  | cut -f2 -d\")
do
	if [ -f $zone.orig ]
	then
		cp -f $zone.orig $zone
	fi
done

rm -f pdns*.pid
rm -f *_tests

presigned=no
both=no

if [[ "$context" =~ .+-presigned.* ]]
then
	presigned=yes
	port=$((port-100))
	eval "$(echo "$context" | sed -r 's/(.+)(-presigned)(-(.*))?/context=\1 presignedcontext=\4/')"
	if [ -z "$presignedcontext" ]
	then
		presignedcontext=$context
	fi
fi

if [ "${context: -5}" = "-both" ]
then
	both=yes
	port=$((port-100))
	context=${context%-both}
	presignedcontext=$context
fi

optout=0

if [ "${context: -13}" = "-nsec3-optout" ]
then
	optout=1
fi

# check for lua
if grep -q "^#define HAVE_LUA 1" ../config.h
then
  lua_prequery="--lua-prequery-script=./check_stest_source"
  skiplua=0
else
  lua_prequery=""
  skiplua=1
fi

case $context in
		ext-nsd | ext-nsd-nsec | ext-nsd-nsec3 | ext-nsd-nsec3-optout)
			case $context in
				ext-nsd)
					tonsd unsigned
					extracontexts="extnsd"
					skipreasons="nsd nodnssec nodyndns"
					;;
				ext-nsd-nsec)
					tonsd nsec
					extracontexts="extnsd dnssec"
					skipreasons="nsd nodyndns"
					;;
				ext-nsd-nsec3)
					tonsd nsec3
					extracontexts="extnsd dnssec nsec3"
					skipreasons="nsd nsec3 nodyndns"
					;;
				ext-nsd-nsec3-optout)
					tonsd nsec3-optout
					extracontexts="extnsd dnssec nsec3 nsec3-optout"
					skipreasons="nsd optout nodyndns"
					;;
			esac
			nsd -c nsd.conf -P pdns.pid -d &
			sleep 5
			;;

		ext-bind | ext-bind-nsec | ext-bind-nsec3 | ext-bind-nsec3-optout)
			case $context in
				ext-bind)
					tobind unsigned
					extracontexts="extbind"
					skipreasons="bind nodnssec nodyndns"
					;;
				ext-bind-nsec)
					tobind nsec
					extracontexts="extbind dnssec"
					skipreasons="bind nodyndns"
					;;
				ext-bind-nsec3)
					tobind nsec3
					extracontexts="extbind dnssec nsec3"
					skipreasons="bind nsec3 nodyndns"
					;;
				ext-bind-nsec3-optout)
					tobind nsec3-optout
					extracontexts="extbind dnssec nsec3 nsec3-optout"
					skipreasons="bind optout nodyndns"
					;;
			esac
			named -c bind.conf -g &
			sleep 5
			;;

		bind)
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=bind --bind-config=./named.conf                \
				--send-root-referral    \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--bind-ignore-broken-records=yes &
			skipreasons="nodnssec nodyndns"
			bindwait
			;;

		bind-dnssec | bind-dnssec-nsec3 | bind-dnssec-nsec3-optout | bind-dnssec-nsec3-narrow)
			rm -f dnssec.sqlite3
			../pdns/pdnssec --config-dir=. create-bind-db dnssec.sqlite3

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone
				if [ $context = bind-dnssec-nsec3 ] || [ $context = bind-dnssec-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. set-nsec3 $zone "1 $optout 1 abcd" 2>&1
				elif [ $context = bind-dnssec-nsec3-narrow ]
				then
					../pdns/pdnssec --config-dir=. set-nsec3 $zone '1 1 1 abcd' narrow 2>&1
				fi
			done

			if [ $context = bind-dnssec-nsec3 ]
			then
				extracontexts="bind dnssec nsec3"
				skipreasons="nsec3 nodyndns"
			elif [ $context = bind-dnssec-nsec3-optout ]
			then
				extracontexts="bind dnssec nsec3 nsec3-optout"
				skipreasons="optout nodyndns"
			elif [ $context = bind-dnssec-nsec3-narrow ]
			then
				extracontexts="bind dnssec narrow"
				skipreasons="narrow nodyndns"
			else
				extracontexts="bind dnssec"
				skipreasons="nodyndns"
			fi

			../pdns/pdnssec --config-dir=. import-tsig-key test $ALGORITHM $KEY
			../pdns/pdnssec --config-dir=. activate-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=bind --bind-config=./named.conf \
				--bind-dnssec-db=./dnssec.sqlite3 \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config \
				--bind-ignore-broken-records=yes $lua_prequery &
			bindwait
			;;

		gmysql-nodnssec)
			[ -z "$GMYSQLDB" ] && GMYSQLDB=pdnstest
			[ -z "$GMYSQLUSER" ] && GMYSQLUSER=root
			[ -z "$GMYSQLHOST" ] && GMYSQLHOST=localhost
			[ -z "$GMYSQLPASSWD" ] && GMYSQLPASSWD=''

			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" --force drop "$GMYSQLDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" create "$GMYSQLDB"
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../modules/gmysqlbackend/no-dnssec.schema.mysql.sql

			tosql gmysql | mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB"

			cat > pdns-gmysql.conf << __EOF__
launch=gmysql
gmysql-dbname=$GMYSQLDB
gmysql-user=$GMYSQLUSER
gmysql-host=$GMYSQLHOST
gmysql-password=$GMYSQLPASSWD
__EOF__

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gmysql \
				--master --send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config \
				--gmysql-dbname="$GMYSQLDB" \
				--gmysql-user="$GMYSQLUSER" \
				--gmysql-host="$GMYSQLHOST" \
				--gmysql-password="$GMYSQLPASSWD" &
			skipreasons=nodnssec
			;;
		mydns)
			[ -z "$MYDNSDB" ] && MYDNSDB=pdnstest
			[ -z "$MYDNSUSER" ] && MYDNSUSER=root
			[ -z "$MYDNSHOST" ] && MYDNSHOST=localhost
			[ -z "$MYDNSPASSWD" ] && MYDNSPASSWD=''

			mysqladmin --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" --force drop "$MYDNSDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" create "$MYDNSDB"
			mysql --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" \
				"$MYDNSDB" < ../modules/mydnsbackend/schema.sql

			tosql mydns | grep -v 'double\.example\.com' | mysql --user="$MYDNSUSER" --password="$MYDNSPASSWD" --host="$MYDNSHOST" \
				"$MYDNSDB"

			cat > pdns-mydns.conf << __EOF__
launch=mydns
mydns-dbname=$MYDNSDB
mydns-user=$MYDNSUSER
mydns-host=$MYDNSHOST
mydns-password=$MYDNSPASSWD
__EOF__
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=mydns \
				--master --send-root-referral \
				--cache-ttl=0 --no-config \
				--mydns-rr-active=no --mydns-soa-active=no --mydns-use-minimal-ttl=no \
				--mydns-dbname="$MYDNSDB" \
				--mydns-user="$MYDNSUSER" \
				--mydns-host="$MYDNSHOST" \
				--mydns-password="$MYDNSPASSWD" &
			skipreasons="nodnssec noent nodyndns"
			;;

		gmysql | gmysql-nsec3 | gmysql-nsec3-optout |gmysql-nsec3-narrow)
			[ -z "$GMYSQLDB" ] && GMYSQLDB=pdnstest
			[ -z "$GMYSQLUSER" ] && GMYSQLUSER=root
			[ -z "$GMYSQLHOST" ] && GMYSQLHOST=localhost
			[ -z "$GMYSQLPASSWD" ] && GMYSQLPASSWD=''

			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" --force drop "$GMYSQLDB" \
				|| echo ignoring mysqladmin drop failure
			mysqladmin --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" create "$GMYSQLDB"
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../modules/gmysqlbackend/no-dnssec.schema.mysql.sql
			mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB" < ../modules/gmysqlbackend/dnssec.schema.mysql.sql

			tosql gmysql | mysql --user="$GMYSQLUSER" --password="$GMYSQLPASSWD" --host="$GMYSQLHOST" \
				"$GMYSQLDB"

			cat > pdns-gmysql.conf << __EOF__
launch=gmysql
gmysql-dbname=$GMYSQLDB
gmysql-user=$GMYSQLUSER
gmysql-host=$GMYSQLHOST
gmysql-password=$GMYSQLPASSWD
gmysql-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gmysql
				if [ $context = gmysql-nsec3 ] || [ $context = gmysql-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gmysql set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
				elif [ $context = gmysql-nsec3-narrow ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gmysql set-nsec3 $zone '1 1 1 abcd' narrow 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gmysql rectify-zone $zone 2>&1
				fi
				

			done

			../pdns/pdnssec --config-dir=. --config-name=gmysql import-tsig-key test $ALGORITHM $KEY
			../pdns/pdnssec --config-dir=. --config-name=gmysql activate-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch --launch+=random --launch+=gmysql --launch+=random --gmysql-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes --experimental-direct-dnskey=yes \
				--cache-ttl=$cachettl --no-config \
				--gmysql-dbname="$GMYSQLDB" \
				--gmysql-user="$GMYSQLUSER" \
				--gmysql-host="$GMYSQLHOST" \
				--gmysql-password="$GMYSQLPASSWD" $lua_prequery &
			if [ $context = gmysql-nsec3 ]
			then
				extracontexts="dnssec nsec3"
				skipreasons="nsec3"
			elif [ $context = gmysql-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
				skipreasons="optout"
			elif [ $context = gmysql-nsec3-narrow ]
			then
				extracontexts="dnssec narrow"
				skipreasons="narrow"
			else
				extracontexts="dnssec"
			fi

			;;	
		gpgsql | gpgsql-nsec3 | gpgsql-nsec3-optout)
			[ -z "$GPGSQLDB" ] && GPGSQLDB=pdnstest
			[ -z "$GPGSQLUSER" ] && GPGSQLUSER=$(whoami)

			dropdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring dropdb failure
			createdb --user="$GPGSQLUSER" "$GPGSQLDB" || echo ignoring createdb failure # FIXME
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../modules/gpgsqlbackend/no-dnssec.schema.pgsql.sql
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../modules/gpgsqlbackend/dnssec.schema.pgsql.sql

			tosql gpgsql | psql --user="$GPGSQLUSER" "$GPGSQLDB" 2>&1 | uniq -c

			cat > pdns-gpgsql.conf << __EOF__
launch=gpgsql
gpgsql-dbname=$GPGSQLDB
gpgsql-user=$GPGSQLUSER
gpgsql-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gpgsql
				if [ $context = gpgsql-nsec3 ] || [ $context = gpgsql-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gpgsql set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gpgsql rectify-zone $zone 2>&1
				fi
			done

			../pdns/pdnssec --config-dir=. --config-name=gpgsql import-tsig-key test $ALGORITHM $KEY
			../pdns/pdnssec --config-dir=. --config-name=gpgsql activate-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gpgsql --gpgsql-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gpgsql-dbname="$GPGSQLDB" \
				--gpgsql-user="$GPGSQLUSER" $lua_prequery &
			if [ $context = gpgsql-nsec3 ]
			then
				extracontexts="dnssec nsec3"
			elif [ $context = gpgsql-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
			elif [ $context = gpgsql-nsec3-narrow ]
			then
				extracontexts="dnssec narrow"
			else
				extracontexts="dnssec"
			fi
			skipreasons="nodyndns"

			;;
		gpgsql-nodnssec)
			[ -z "$GPGSQLDB" ] && GPGSQLDB=pdnstest
			[ -z "$GPGSQLUSER" ] && GPGSQLUSER=$(whoami)

			dropdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring mysqladmin drop failure
			createdb --user="$GPGSQLUSER" "$GPGSQLDB"	|| echo ignoring mysqladmin drop failure
			psql --user="$GPGSQLUSER" "$GPGSQLDB" < ../modules/gpgsqlbackend/no-dnssec.schema.pgsql.sql

			tosql gpgsql | psql --user="$GPGSQLUSER" "$GPGSQLDB" 2>&1 | uniq -c

			cat > pdns-gpgsql.conf << __EOF__
launch=gpgsql
gpgsql-dbname=$GPGSQLDB
gpgsql-user=$GPGSQLUSER
__EOF__

			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gpgsql rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gpgsql \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gpgsql-dbname="$GPGSQLDB" \
				--gpgsql-user="$GPGSQLUSER" &
			skipreasons="nodnssec nodyndns"
			;;	


		gsqlite3-nodnssec)
			rm -f pdns.sqlite3
			sqlite3 pdns.sqlite3 < ../modules/gsqlite3backend/no-dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns.sqlite3
			echo ANALYZE\; | sqlite3 pdns.sqlite3

			cat > pdns-gsqlite3.conf << __EOF__
launch=gsqlite3
gsqlite3-database=pdns.sqlite3
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				../pdns/pdnssec --config-dir=. --config-name=gsqlite3 rectify-zone $zone 2>&1
			done

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gsqlite3 \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gsqlite3-database=pdns.sqlite3 &
			skipreasons="nodnssec nodyndns"

			;;
		opendbx-sqlite3)
			rm -f pdns-opendbx.sqlite3
			sqlite3 pdns-opendbx.sqlite3 < ../modules/gsqlite3backend/no-dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns-opendbx.sqlite3
			sqlite3 pdns-opendbx.sqlite3 "ALTER TABLE domains ADD status CHARACTER(1) NOT NULL DEFAULT 'A'; \
				ALTER TABLE domains ADD auto_serial INTEGER DEFAULT 0;"
			echo ANALYZE\; | sqlite3 pdns-opendbx.sqlite3

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=opendbx \
				--send-root-referral \
				--cache-ttl=$cachettl --no-config \
				--opendbx-backend=sqlite3 --opendbx-host-read=./ --opendbx-host-write=./ \
				--opendbx-database=pdns-opendbx.sqlite3 &
			skipreasons="nodnssec noent nodyndns"

			;;
		gsqlite3 | gsqlite3-nsec3 | gsqlite3-nsec3-optout)
			rm -f pdns.sqlite3
			sqlite3 pdns.sqlite3 < ../modules/gsqlite3backend/no-dnssec.schema.sqlite3.sql
			sqlite3 pdns.sqlite3 < ../modules/gsqlite3backend/dnssec.schema.sqlite3.sql
			tosql gsqlite | sqlite3 pdns.sqlite3
			echo ANALYZE\; | sqlite3 pdns.sqlite3

			cat > pdns-gsqlite3.conf << __EOF__
launch=gsqlite3
gsqlite3-database=pdns.sqlite3
gsqlite3-dnssec
__EOF__
			for zone in $(grep zone named.conf  | cut -f2 -d\")
			do
				securezone $zone gsqlite3
				if [ $context = gsqlite3-nsec3 ] || [ $context = gsqlite3-nsec3-optout ]
				then
					../pdns/pdnssec --config-dir=. --config-name=gsqlite3 set-nsec3 $zone "1 $optout 1 abcd" 2>&1
					../pdns/pdnssec --config-dir=. --config-name=gsqlite3 rectify-zone $zone 2>&1
				fi
			done

			../pdns/pdnssec --config-dir=. --config-name=gsqlite3 import-tsig-key test $ALGORITHM $KEY
			../pdns/pdnssec --config-dir=. --config-name=gsqlite3 activate-tsig-key tsig.com test master

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./  \
				--no-shuffle --launch=gsqlite3 --gsqlite3-dnssec \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--cache-ttl=$cachettl --no-config \
				--gsqlite3-database=pdns.sqlite3 $lua_prequery &
			if [ $context = gsqlite3-nsec3 ]
			then
				extracontexts="dnssec nsec3"
			elif [ $context = gsqlite3-nsec3-optout ]
			then
				extracontexts="dnssec nsec3 nsec3-optout"
			else
				extracontexts="dnssec"
			fi
			skipreasons="nodyndns"
			;;
		tinydns)
			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=tinydns \
			 --cache-ttl=$cachettl --no-config \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--tinydns-dbfile=../modules/tinydnsbackend/data.cdb & 
			skipreasons="nodnssec noent nodyndns"
			;;
		remotebackend-*)
			remotetype=$(echo $context | cut -d- -f 2)
			remotesec=$(echo $context | cut -d- -f 3)
			narrow=$(echo $context | cut -d- -f 4)
			testsdir=../modules/remotebackend/regression-tests/

			# cleanup unbound-host.conf to avoid failures
			rm -f unbound-host.conf

			case $remotetype in
			http)
				connstr="http:url=http://localhost:62434/dns"
				rm -f remotebackend-server.log
				rm -f remotebackend-access.log
				$testsdir/http-backend.rb &
				echo $! > pdns-remotebackend.pid
				set +e
				# make sure it runs before continuing
				loopcount=0
				while [ $loopcount -lt 20 ]; do
					res=$(curl http://localhost:62434/ping 2>/dev/null)
					if [ "x$res" == "xpong" ]
					then
						break
					fi
					sleep 1
					let loopcount=loopcount+1
				done
				set -e
				;;
			unix)
				connstr="unix:path=/tmp/remote.socket"
				socat unix-listen:/tmp/remote.socket,fork exec:$testsdir/unix-backend.rb &
				echo $! > pdns-remotebackend.pid
				;;
			pipe)
				connstr="pipe:command=$testsdir/pipe-backend.rb"
				;;
			*)
				echo "Invalid usage"
				exit 1
				;;
			esac

			skipreasons="nodnssec nodyndns"

			if [ "$remotesec" = "nsec3" ]
			then
				remotedosec="yes"
				if [ "$narrow" = "narrow" ]
				then
					extracontexts="dnssec nsec3 narrow"
					skipreasons="narrow nsec3 nodyndns"
				else
					extracontexts="dnssec nsec3"
					skipreasons="nsec3 nodyndns"
				fi
				
				remote_add_param="--remote-dnssec=yes"
			elif [ "$remotesec" = "dnssec" ]
			then
				remotedosec="yes"
				remote_add_param="--remote-dnssec=yes"
				extracontexts="dnssec"
				skipreasons="nonsec3 nonarrow nodyndns"
			fi

			# generate pdns.conf for pdnssec
			cat > pdns-remote.conf <<EOF
launch=remote
remote-connection-string=$connstr
EOF

			$RUNWRAPPER $PDNS --daemon=no --local-port=$port --socket-dir=./ \
				--no-shuffle --launch=remote \
				--query-logging --loglevel=9 --cache-ttl=$cachettl --no-config \
				--send-root-referral \
				--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
				--remote-connection-string="$connstr" $remote_add_param &

			echo "Setting up test database..."
			# setup test database
			rm -f $testsdir/remote.sqlite3
			sqlite3 $testsdir/remote.sqlite3 < $testsdir/test-schema.sql
			chmod 0666 $testsdir/remote.sqlite3

			if [ "$remotedosec" = "yes" ]
			then
				echo "remote-dnssec=yes" >> pdns-remote.conf
				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.ksk ksk
				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.zsk.1 zsk
				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key example.com $testsdir/example.com.zsk.2 zsk
				../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 1
				../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 2
				../pdns/pdnssec --config-dir=. --config-name=remote deactivate-zone-key example.com 3

				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.ksk ksk
				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.zsk.1 zsk
				../pdns/pdnssec --config-dir=. --config-name=remote import-zone-key up.example.com $testsdir/up.example.com.zsk.2 zsk
				../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 4
				../pdns/pdnssec --config-dir=. --config-name=remote activate-zone-key example.com 5
				../pdns/pdnssec --config-dir=. --config-name=remote deactivate-zone-key example.com 6

				if [ "$remotesec" = "nsec3" ]
				then
					../pdns/pdnssec --config-dir=. --config-name=remote set-nsec3 example.com
					../pdns/pdnssec --config-dir=. --config-name=remote set-nsec3 up.example.com
				fi
			fi
			;;
		*)
			echo unknown context $context
			: > passed_tests
			echo 'unknown-context-'"$context" > failed_tests
			./toxml $context
			exit 1
esac

if [ "$skiplua" == "1" ]; then
	skipreasons="$skipreasons nolua"
fi

check_process

startslave ()
{
	skipreasons="$skipreasons presigned nodyndns"
	if [ ${presignedcontext:0:6} = gmysql ]
	then
		context=${context}-presigned
		[ -z "$GMYSQL2DB" ] && GMYSQL2DB=pdnstest2
		[ -z "$GMYSQL2USER" ] && GMYSQL2USER=root
		[ -z "$GMYSQL2HOST" ] && GMYSQL2HOST=localhost
		[ -z "$GMYSQL2PASSWD" ] && GMYSQL2PASSWD=''

		mysqladmin --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" --force drop "$GMYSQL2DB" \
			|| echo ignoring mysqladmin drop failure
		mysqladmin --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" create "$GMYSQL2DB"
		mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" < ../modules/gmysqlbackend/no-dnssec.schema.mysql.sql
		mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" < ../modules/gmysqlbackend/dnssec.schema.mysql.sql

		for zone in $(grep zone named.conf  | cut -f2 -d\" | tac)
		do
			mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" \
			"$GMYSQL2DB" \
			-e "INSERT INTO domains (name, type, master) VALUES('$zone','SLAVE','127.0.0.1:$port')"
		done

		set +e
		echo $skipreasons | grep -q nodnssec
		if [ $? -ne 0 ]; then
			mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" "$GMYSQL2DB" \
			-e "INSERT INTO tsigkeys (name, algorithm,secret) VALUES('test', '$ALGORITHM', '$KEY')"
			mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" "$GMYSQL2DB" \
			-e "INSERT INTO domainmetadata (domain_id, kind, content) SELECT id, 'AXFR-MASTER-TSIG', 'test' FROM domains WHERE name = 'tsig.com'"
			echo $skipreasons | grep -q nolua
			if [ $? -ne 0 ]; then
				mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQL2HOST" "$GMYSQL2DB" \
				-e "INSERT INTO domainmetadata (domain_id,kind,content) SELECT id,'AXFR-SOURCE','127.0.0.2' FROM domains WHERE name = 'stest.com'"
			fi
		fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=gmysql --gmysql-dnssec \
			--send-root-referral \
			--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
			--cache-ttl=$cachettl --query-cache-ttl=$cachettl --no-config --slave --retrieval-threads=4 \
			--gmysql-dbname="$GMYSQL2DB" \
			--gmysql-user="$GMYSQL2USER" \
			--gmysql-host="$GMYSQL2HOST" \
			--gmysql-password="$GMYSQL2PASSWD" \
			--config-name=gmysql2 |& egrep -v "update records set ordername|insert into records" &
		echo 'waiting for zones to be slaved'
		loopcount=0
		while [ $loopcount -lt 20 ]
		do
			sleep 5
			todo=$(mysql --user="$GMYSQL2USER" --password="$GMYSQL2PASSWD" --host="$GMYSQl2HOST" \
				   "$GMYSQL2DB" -ss -e 'SELECT COUNT(id) FROM domains WHERE last_check IS NULL')
			if [ $todo = 0 ]
			then
				break
			fi
			let loopcount=loopcount+1
		done
		if [ $todo -ne 0 ]; then 
			echo "AXFR FAILED" >> failed_tests
		fi
	elif [ ${presignedcontext:0:8} = gsqlite3 ]
	then
		context=${context}-presigned
		rm -f pdns.sqlite31
		sqlite3 pdns.sqlite31 < ../modules/gsqlite3backend/no-dnssec.schema.sqlite3.sql
		sqlite3 pdns.sqlite31 < ../modules/gsqlite3backend/dnssec.schema.sqlite3.sql

		for zone in $(grep zone named.conf  | cut -f2 -d\" | tac)
		do
			sqlite3 pdns.sqlite31 "INSERT INTO domains (name, type, master) VALUES('$zone','SLAVE','127.0.0.1:$port');"
		done

		set +e
		echo $skipreasons | grep -q nodnssec
		if [ $? -ne 0 ]; then
			sqlite3 pdns.sqlite31 "INSERT INTO tsigkeys (name,algorithm,secret) VALUES('test','$ALGORITHM', '$KEY')"
			sqlite3 pdns.sqlite31 "INSERT INTO domainmetadata (domain_id, kind, content) SELECT id, 'AXFR-MASTER-TSIG', 'test' FROM domains WHERE name = 'tsig.com'"
			echo $skipreasons | grep -q nolua
			if [ $? -ne 0 ]; then
				sqlite3 pdns.sqlite31  "INSERT INTO domainmetadata (domain_id,kind,content) SELECT id,'AXFR-SOURCE','127.0.0.2' FROM domains WHERE name = 'stest.com'"
			fi
		fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=gsqlite3 --gsqlite3-dnssec \
			--fancy-records --send-root-referral \
			--cache-ttl=0 --query-cache-ttl=0 --no-config --slave --retrieval-threads=4 \
			--gsqlite3-database=pdns.sqlite31 --gsqlite3-pragma-synchronous=0 \
			--config-name=gsqlite32 |& egrep -v "update records set ordername|insert into records" &
		echo 'waiting for zones to be slaved'
		set +e
		loopcount=0
		while [ $loopcount -lt 20 ]
		do
			sleep 5
			todo=$(sqlite3 pdns.sqlite31 'SELECT COUNT(id) FROM domains WHERE last_check IS NULL')
			if [ $todo -eq 0 ]
			then
				if [ $todo = 0 ]
				then
					break
				fi
			fi
			let loopcount=loopcount+1
		done
		if [ $todo -ne 0 ]; then
				echo "AXFR FAILED" >> failed_tests
		fi
		set -e
		sqlite3 pdns.sqlite31 ANALYZE;
	elif [ ${presignedcontext:0:4} = bind ]
	then
		context=${context}-presigned
		sed -e 's/type master;/type slave;\n\tmasters { 127.0.0.1:'$port'; };/' -e 's/file "\([^"]\+\)/file "\1-slave/' < named.conf > named-slave.conf

		for zone in $(grep zone named.conf  | cut -f2 -d\")
		do
			rm -rf $zone-slave
		done
		
		rm -f dnssec-slave.sqlite3

		../pdns/pdnssec --config-dir=. create-bind-db dnssec-slave.sqlite3

		set +e
		echo $skipreasons | grep -q nodnssec
		if [ $? -ne 0 ]; then
			sqlite3 dnssec-slave.sqlite3 "INSERT INTO tsigkeys (name, algorithm,secret) VALUES('test', '$ALGORITHM', '$KEY')"
			sqlite3 dnssec-slave.sqlite3 "INSERT INTO domainmetadata (domain, kind, content) SELECT 'tsig.com', 'AXFR-MASTER-TSIG', 'test'"
			echo $skipreasons | grep -q nolua
			if [ $? -ne 0 ]; then
				sqlite3 dnssec-slave.sqlite3 "INSERT INTO domainmetadata (domain,kind,content) SELECT 'stest.com','AXFR-SOURCE','127.0.0.2'"
			fi
		fi
		set -e

		port=$((port+100))

		$RUNWRAPPER $PDNS2 --daemon=no --local-port=$port --socket-dir=./  \
			--no-shuffle --launch=bind --bind-config=./named-slave.conf --slave         \
			--send-root-referral --retrieval-threads=1  --config-name=bind-slave \
			--allow-2136-from=127.0.0.0/8 --experimental-rfc2136=yes \
			--cache-ttl=$cachettl --no-config --bind-dnssec-db=./dnssec-slave.sqlite3 &
		echo 'waiting for zones to be loaded'
		bindwait bind-slave
	elif [ ${presignedcontext:0:7} = ext-nsd ]
	then
		skipreasons="$skipreasons nsd"
		context=$context-presigned
		cat > nsd-slave.conf << __EOF__
server:
	ip-address: 127.0.0.1@$((port+100))
	database: ./nsd-slave.db
	difffile: ./ixfr-slave.db
	xfrdfile: ./ixfr-slave.state
	zonesdir: .
	username: ""

key:
	name: test
	algorithm: $ALGORITHM
	secret: "$KEY"
__EOF__

		rm -f ixfr-slave.db
		rm -f ixfr-slave.state

		for zone in $(grep zone named.conf  | cut -f2 -d\")
		do
			rm -f $zone-slave

			echo "" >> nsd-slave.conf
			echo "zone:" >> nsd-slave.conf
			echo "	name: \"${zone}\"" >> nsd-slave.conf
			echo "	zonefile: \"${zone}-slave\"" >> nsd-slave.conf
			if [ "${zone}" = "tsig.com" ]
			then
				echo "	allow-notify: 127.0.0.1 test" >> nsd-slave.conf
				echo "	request-xfr: AXFR 127.0.0.1@$port test" >> nsd-slave.conf
				echo "	provide-xfr: 0.0.0.0/0 test" >> nsd-slave.conf
				echo "	provide-xfr: ::0/0 test" >> nsd-slave.conf
			else
				echo "	allow-notify: 127.0.0.1 NOKEY" >> nsd-slave.conf
				echo "	request-xfr: AXFR 127.0.0.1@$port NOKEY" >> nsd-slave.conf
				echo "	provide-xfr: 0.0.0.0/0 NOKEY" >> nsd-slave.conf
				echo "	provide-xfr: ::0/0 NOKEY" >> nsd-slave.conf
			fi
		done

		port=$((port+100))
		nsdc -c nsd-slave.conf rebuild

		nsd -c nsd-slave.conf -P pdns-slave.pid -d &
		sleep 20
	elif [ ${presignedcontext:0:8} = ext-bind ]
	then
		skipreasons="$skipreasons bind"
		context=$context-presigned
		cat > bind-slave.conf << __EOF__
options {
	dnssec-enable yes;
	listen-on port $(($port+100)) { 127.0.0.1; };
	minimal-responses yes;
	pid-file "pdns-slave.pid";
};

key test {
	algorithm $ALGORITHM;
	secret "$KEY";
};
__EOF__

		rm -f ixfr-slave.db
		rm -f ixfr-slave.state

		for zone in $(grep zone named.conf  | cut -f2 -d\")
		do
			rm -f $zone-slave

			echo "" >> bind-slave.conf
			echo "zone \"${zone}\" {" >> bind-slave.conf
			echo "	type slave;" >> bind-slave.conf
			echo "	file \"${zone}-slave\";" >> bind-slave.conf
			if [ "${zone}" = "tsig.com" ]
			then
				echo "	masters port $port { 127.0.0.1 key test; };" >> bind-slave.conf
				echo "	allow-transfer { key test; none; };" >> bind-slave.conf
			else
				echo "	masters port $port { 127.0.0.1; };" >> bind-slave.conf
			fi
			echo "};" >> bind-slave.conf
		done

		port=$((port+100))

		named -c bind-slave.conf -g &
		sleep 20
	fi
}

dotests () {
	nameserver=127.0.0.1 ./runtests $spectest
	./toxml
	./totar

	if [ -s "./failed_tests" ]
	then
		for t in `cat failed_tests`
		do
			echo -e "\n\n$t"
			cat $t/diff
		done
		if [ "${!1}" -eq 0 ]
		then
			eval "$1=1"
		fi
	fi
}

## TODO: give pdns a few seconds to startup or fail, then check if it did not fail
## TODO: give sdig a timeout

RETVAL=0

export port
export context
export extracontexts
export skipreasons
export testsdir
export optout

sleep 2

if [ $presigned = no ] || [ $both = yes ]
then
	dotests RETVAL
fi

if [ $presigned = yes ] || [ $both = yes ]
then
	startslave

	export port
	export context
	export skipreasons

	dotests RETVAL
fi

if [ "$wait" = "wait" ]
then
	echo tests done! push enter to terminate instance
	read l
fi

kill $(cat pdns*.pid)
rm pdns*.pid || true
exit $RETVAL
